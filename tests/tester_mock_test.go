// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package tests

//go:generate minimock -i github.com/gojuno/minimock/v3.Tester -o tester_mock_test.go -n TesterMock -p tests

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TesterMock implements minimock.Tester
type TesterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCleanup          func(f func())
	inspectFuncCleanup   func(f func())
	afterCleanupCounter  uint64
	beforeCleanupCounter uint64
	CleanupMock          mTesterMockCleanup

	funcError          func(p1 ...interface{})
	inspectFuncError   func(p1 ...interface{})
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mTesterMockError

	funcErrorf          func(format string, args ...interface{})
	inspectFuncErrorf   func(format string, args ...interface{})
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mTesterMockErrorf

	funcFailNow          func()
	inspectFuncFailNow   func()
	afterFailNowCounter  uint64
	beforeFailNowCounter uint64
	FailNowMock          mTesterMockFailNow

	funcFatal          func(args ...interface{})
	inspectFuncFatal   func(args ...interface{})
	afterFatalCounter  uint64
	beforeFatalCounter uint64
	FatalMock          mTesterMockFatal

	funcFatalf          func(format string, args ...interface{})
	inspectFuncFatalf   func(format string, args ...interface{})
	afterFatalfCounter  uint64
	beforeFatalfCounter uint64
	FatalfMock          mTesterMockFatalf
}

// NewTesterMock returns a mock for minimock.Tester
func NewTesterMock(t minimock.Tester) *TesterMock {
	m := &TesterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CleanupMock = mTesterMockCleanup{mock: m}
	m.CleanupMock.callArgs = []*TesterMockCleanupParams{}

	m.ErrorMock = mTesterMockError{mock: m}
	m.ErrorMock.callArgs = []*TesterMockErrorParams{}

	m.ErrorfMock = mTesterMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*TesterMockErrorfParams{}

	m.FailNowMock = mTesterMockFailNow{mock: m}

	m.FatalMock = mTesterMockFatal{mock: m}
	m.FatalMock.callArgs = []*TesterMockFatalParams{}

	m.FatalfMock = mTesterMockFatalf{mock: m}
	m.FatalfMock.callArgs = []*TesterMockFatalfParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTesterMockCleanup struct {
	optional           bool
	mock               *TesterMock
	defaultExpectation *TesterMockCleanupExpectation
	expectations       []*TesterMockCleanupExpectation

	callArgs []*TesterMockCleanupParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TesterMockCleanupExpectation specifies expectation struct of the Tester.Cleanup
type TesterMockCleanupExpectation struct {
	mock      *TesterMock
	params    *TesterMockCleanupParams
	paramPtrs *TesterMockCleanupParamPtrs

	Counter uint64
}

// TesterMockCleanupParams contains parameters of the Tester.Cleanup
type TesterMockCleanupParams struct {
	f func()
}

// TesterMockCleanupParamPtrs contains pointers to parameters of the Tester.Cleanup
type TesterMockCleanupParamPtrs struct {
	f *func()
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCleanup *mTesterMockCleanup) Optional() *mTesterMockCleanup {
	mmCleanup.optional = true
	return mmCleanup
}

// Expect sets up expected params for Tester.Cleanup
func (mmCleanup *mTesterMockCleanup) Expect(f func()) *mTesterMockCleanup {
	if mmCleanup.mock.funcCleanup != nil {
		mmCleanup.mock.t.Fatalf("TesterMock.Cleanup mock is already set by Set")
	}

	if mmCleanup.defaultExpectation == nil {
		mmCleanup.defaultExpectation = &TesterMockCleanupExpectation{}
	}

	if mmCleanup.defaultExpectation.paramPtrs != nil {
		mmCleanup.mock.t.Fatalf("TesterMock.Cleanup mock is already set by ExpectParams functions")
	}

	mmCleanup.defaultExpectation.params = &TesterMockCleanupParams{f}
	for _, e := range mmCleanup.expectations {
		if minimock.Equal(e.params, mmCleanup.defaultExpectation.params) {
			mmCleanup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCleanup.defaultExpectation.params)
		}
	}

	return mmCleanup
}

// ExpectFParam1 sets up expected param f for Tester.Cleanup
func (mmCleanup *mTesterMockCleanup) ExpectFParam1(f func()) *mTesterMockCleanup {
	if mmCleanup.mock.funcCleanup != nil {
		mmCleanup.mock.t.Fatalf("TesterMock.Cleanup mock is already set by Set")
	}

	if mmCleanup.defaultExpectation == nil {
		mmCleanup.defaultExpectation = &TesterMockCleanupExpectation{}
	}

	if mmCleanup.defaultExpectation.params != nil {
		mmCleanup.mock.t.Fatalf("TesterMock.Cleanup mock is already set by Expect")
	}

	if mmCleanup.defaultExpectation.paramPtrs == nil {
		mmCleanup.defaultExpectation.paramPtrs = &TesterMockCleanupParamPtrs{}
	}
	mmCleanup.defaultExpectation.paramPtrs.f = &f

	return mmCleanup
}

// Inspect accepts an inspector function that has same arguments as the Tester.Cleanup
func (mmCleanup *mTesterMockCleanup) Inspect(f func(f func())) *mTesterMockCleanup {
	if mmCleanup.mock.inspectFuncCleanup != nil {
		mmCleanup.mock.t.Fatalf("Inspect function is already set for TesterMock.Cleanup")
	}

	mmCleanup.mock.inspectFuncCleanup = f

	return mmCleanup
}

// Return sets up results that will be returned by Tester.Cleanup
func (mmCleanup *mTesterMockCleanup) Return() *TesterMock {
	if mmCleanup.mock.funcCleanup != nil {
		mmCleanup.mock.t.Fatalf("TesterMock.Cleanup mock is already set by Set")
	}

	if mmCleanup.defaultExpectation == nil {
		mmCleanup.defaultExpectation = &TesterMockCleanupExpectation{mock: mmCleanup.mock}
	}

	return mmCleanup.mock
}

// Set uses given function f to mock the Tester.Cleanup method
func (mmCleanup *mTesterMockCleanup) Set(f func(f func())) *TesterMock {
	if mmCleanup.defaultExpectation != nil {
		mmCleanup.mock.t.Fatalf("Default expectation is already set for the Tester.Cleanup method")
	}

	if len(mmCleanup.expectations) > 0 {
		mmCleanup.mock.t.Fatalf("Some expectations are already set for the Tester.Cleanup method")
	}

	mmCleanup.mock.funcCleanup = f
	return mmCleanup.mock
}

// Times sets number of times Tester.Cleanup should be invoked
func (mmCleanup *mTesterMockCleanup) Times(n uint64) *mTesterMockCleanup {
	if n == 0 {
		mmCleanup.mock.t.Fatalf("Times of TesterMock.Cleanup mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCleanup.expectedInvocations, n)
	return mmCleanup
}

func (mmCleanup *mTesterMockCleanup) invocationsDone() bool {
	if len(mmCleanup.expectations) == 0 && mmCleanup.defaultExpectation == nil && mmCleanup.mock.funcCleanup == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCleanup.mock.afterCleanupCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCleanup.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Cleanup implements minimock.Tester
func (mmCleanup *TesterMock) Cleanup(f func()) {
	mm_atomic.AddUint64(&mmCleanup.beforeCleanupCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanup.afterCleanupCounter, 1)

	if mmCleanup.inspectFuncCleanup != nil {
		mmCleanup.inspectFuncCleanup(f)
	}

	mm_params := TesterMockCleanupParams{f}

	// Record call args
	mmCleanup.CleanupMock.mutex.Lock()
	mmCleanup.CleanupMock.callArgs = append(mmCleanup.CleanupMock.callArgs, &mm_params)
	mmCleanup.CleanupMock.mutex.Unlock()

	for _, e := range mmCleanup.CleanupMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCleanup.CleanupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanup.CleanupMock.defaultExpectation.Counter, 1)
		mm_want := mmCleanup.CleanupMock.defaultExpectation.params
		mm_want_ptrs := mmCleanup.CleanupMock.defaultExpectation.paramPtrs

		mm_got := TesterMockCleanupParams{f}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.f != nil && !minimock.Equal(*mm_want_ptrs.f, mm_got.f) {
				mmCleanup.t.Errorf("TesterMock.Cleanup got unexpected parameter f, want: %#v, got: %#v%s\n", *mm_want_ptrs.f, mm_got.f, minimock.Diff(*mm_want_ptrs.f, mm_got.f))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCleanup.t.Errorf("TesterMock.Cleanup got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCleanup.funcCleanup != nil {
		mmCleanup.funcCleanup(f)
		return
	}
	mmCleanup.t.Fatalf("Unexpected call to TesterMock.Cleanup. %v", f)

}

// CleanupAfterCounter returns a count of finished TesterMock.Cleanup invocations
func (mmCleanup *TesterMock) CleanupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanup.afterCleanupCounter)
}

// CleanupBeforeCounter returns a count of TesterMock.Cleanup invocations
func (mmCleanup *TesterMock) CleanupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanup.beforeCleanupCounter)
}

// Calls returns a list of arguments used in each call to TesterMock.Cleanup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCleanup *mTesterMockCleanup) Calls() []*TesterMockCleanupParams {
	mmCleanup.mutex.RLock()

	argCopy := make([]*TesterMockCleanupParams, len(mmCleanup.callArgs))
	copy(argCopy, mmCleanup.callArgs)

	mmCleanup.mutex.RUnlock()

	return argCopy
}

// MinimockCleanupDone returns true if the count of the Cleanup invocations corresponds
// the number of defined expectations
func (m *TesterMock) MinimockCleanupDone() bool {
	if m.CleanupMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CleanupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CleanupMock.invocationsDone()
}

// MinimockCleanupInspect logs each unmet expectation
func (m *TesterMock) MinimockCleanupInspect() {
	for _, e := range m.CleanupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TesterMock.Cleanup with params: %#v", *e.params)
		}
	}

	afterCleanupCounter := mm_atomic.LoadUint64(&m.afterCleanupCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CleanupMock.defaultExpectation != nil && afterCleanupCounter < 1 {
		if m.CleanupMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TesterMock.Cleanup")
		} else {
			m.t.Errorf("Expected call to TesterMock.Cleanup with params: %#v", *m.CleanupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanup != nil && afterCleanupCounter < 1 {
		m.t.Error("Expected call to TesterMock.Cleanup")
	}

	if !m.CleanupMock.invocationsDone() && afterCleanupCounter > 0 {
		m.t.Errorf("Expected %d calls to TesterMock.Cleanup but found %d calls",
			mm_atomic.LoadUint64(&m.CleanupMock.expectedInvocations), afterCleanupCounter)
	}
}

type mTesterMockError struct {
	optional           bool
	mock               *TesterMock
	defaultExpectation *TesterMockErrorExpectation
	expectations       []*TesterMockErrorExpectation

	callArgs []*TesterMockErrorParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TesterMockErrorExpectation specifies expectation struct of the Tester.Error
type TesterMockErrorExpectation struct {
	mock      *TesterMock
	params    *TesterMockErrorParams
	paramPtrs *TesterMockErrorParamPtrs

	Counter uint64
}

// TesterMockErrorParams contains parameters of the Tester.Error
type TesterMockErrorParams struct {
	p1 []interface{}
}

// TesterMockErrorParamPtrs contains pointers to parameters of the Tester.Error
type TesterMockErrorParamPtrs struct {
	p1 *[]interface{}
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmError *mTesterMockError) Optional() *mTesterMockError {
	mmError.optional = true
	return mmError
}

// Expect sets up expected params for Tester.Error
func (mmError *mTesterMockError) Expect(p1 ...interface{}) *mTesterMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("TesterMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &TesterMockErrorExpectation{}
	}

	if mmError.defaultExpectation.paramPtrs != nil {
		mmError.mock.t.Fatalf("TesterMock.Error mock is already set by ExpectParams functions")
	}

	mmError.defaultExpectation.params = &TesterMockErrorParams{p1}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// ExpectP1Param1 sets up expected param p1 for Tester.Error
func (mmError *mTesterMockError) ExpectP1Param1(p1 ...interface{}) *mTesterMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("TesterMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &TesterMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("TesterMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &TesterMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.p1 = &p1

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Tester.Error
func (mmError *mTesterMockError) Inspect(f func(p1 ...interface{})) *mTesterMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for TesterMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Tester.Error
func (mmError *mTesterMockError) Return() *TesterMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("TesterMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &TesterMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

// Set uses given function f to mock the Tester.Error method
func (mmError *mTesterMockError) Set(f func(p1 ...interface{})) *TesterMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Tester.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Tester.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Times sets number of times Tester.Error should be invoked
func (mmError *mTesterMockError) Times(n uint64) *mTesterMockError {
	if n == 0 {
		mmError.mock.t.Fatalf("Times of TesterMock.Error mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmError.expectedInvocations, n)
	return mmError
}

func (mmError *mTesterMockError) invocationsDone() bool {
	if len(mmError.expectations) == 0 && mmError.defaultExpectation == nil && mmError.mock.funcError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmError.mock.afterErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Error implements minimock.Tester
func (mmError *TesterMock) Error(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(p1...)
	}

	mm_params := TesterMockErrorParams{p1}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, &mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_want_ptrs := mmError.ErrorMock.defaultExpectation.paramPtrs

		mm_got := TesterMockErrorParams{p1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmError.t.Errorf("TesterMock.Error got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("TesterMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(p1...)
		return
	}
	mmError.t.Fatalf("Unexpected call to TesterMock.Error. %v", p1)

}

// ErrorAfterCounter returns a count of finished TesterMock.Error invocations
func (mmError *TesterMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of TesterMock.Error invocations
func (mmError *TesterMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to TesterMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mTesterMockError) Calls() []*TesterMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*TesterMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *TesterMock) MinimockErrorDone() bool {
	if m.ErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorMock.invocationsDone()
}

// MinimockErrorInspect logs each unmet expectation
func (m *TesterMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TesterMock.Error with params: %#v", *e.params)
		}
	}

	afterErrorCounter := mm_atomic.LoadUint64(&m.afterErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && afterErrorCounter < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TesterMock.Error")
		} else {
			m.t.Errorf("Expected call to TesterMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && afterErrorCounter < 1 {
		m.t.Error("Expected call to TesterMock.Error")
	}

	if !m.ErrorMock.invocationsDone() && afterErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to TesterMock.Error but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorMock.expectedInvocations), afterErrorCounter)
	}
}

type mTesterMockErrorf struct {
	optional           bool
	mock               *TesterMock
	defaultExpectation *TesterMockErrorfExpectation
	expectations       []*TesterMockErrorfExpectation

	callArgs []*TesterMockErrorfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TesterMockErrorfExpectation specifies expectation struct of the Tester.Errorf
type TesterMockErrorfExpectation struct {
	mock      *TesterMock
	params    *TesterMockErrorfParams
	paramPtrs *TesterMockErrorfParamPtrs

	Counter uint64
}

// TesterMockErrorfParams contains parameters of the Tester.Errorf
type TesterMockErrorfParams struct {
	format string
	args   []interface{}
}

// TesterMockErrorfParamPtrs contains pointers to parameters of the Tester.Errorf
type TesterMockErrorfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmErrorf *mTesterMockErrorf) Optional() *mTesterMockErrorf {
	mmErrorf.optional = true
	return mmErrorf
}

// Expect sets up expected params for Tester.Errorf
func (mmErrorf *mTesterMockErrorf) Expect(format string, args ...interface{}) *mTesterMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("TesterMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &TesterMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.paramPtrs != nil {
		mmErrorf.mock.t.Fatalf("TesterMock.Errorf mock is already set by ExpectParams functions")
	}

	mmErrorf.defaultExpectation.params = &TesterMockErrorfParams{format, args}
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// ExpectFormatParam1 sets up expected param format for Tester.Errorf
func (mmErrorf *mTesterMockErrorf) ExpectFormatParam1(format string) *mTesterMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("TesterMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &TesterMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("TesterMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &TesterMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.format = &format

	return mmErrorf
}

// ExpectArgsParam2 sets up expected param args for Tester.Errorf
func (mmErrorf *mTesterMockErrorf) ExpectArgsParam2(args ...interface{}) *mTesterMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("TesterMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &TesterMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("TesterMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &TesterMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.args = &args

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the Tester.Errorf
func (mmErrorf *mTesterMockErrorf) Inspect(f func(format string, args ...interface{})) *mTesterMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for TesterMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by Tester.Errorf
func (mmErrorf *mTesterMockErrorf) Return() *TesterMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("TesterMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &TesterMockErrorfExpectation{mock: mmErrorf.mock}
	}

	return mmErrorf.mock
}

// Set uses given function f to mock the Tester.Errorf method
func (mmErrorf *mTesterMockErrorf) Set(f func(format string, args ...interface{})) *TesterMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the Tester.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the Tester.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	return mmErrorf.mock
}

// Times sets number of times Tester.Errorf should be invoked
func (mmErrorf *mTesterMockErrorf) Times(n uint64) *mTesterMockErrorf {
	if n == 0 {
		mmErrorf.mock.t.Fatalf("Times of TesterMock.Errorf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmErrorf.expectedInvocations, n)
	return mmErrorf
}

func (mmErrorf *mTesterMockErrorf) invocationsDone() bool {
	if len(mmErrorf.expectations) == 0 && mmErrorf.defaultExpectation == nil && mmErrorf.mock.funcErrorf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmErrorf.mock.afterErrorfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmErrorf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Errorf implements minimock.Tester
func (mmErrorf *TesterMock) Errorf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(format, args...)
	}

	mm_params := TesterMockErrorfParams{format, args}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, &mm_params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorf.ErrorfMock.defaultExpectation.params
		mm_want_ptrs := mmErrorf.ErrorfMock.defaultExpectation.paramPtrs

		mm_got := TesterMockErrorfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmErrorf.t.Errorf("TesterMock.Errorf got unexpected parameter format, want: %#v, got: %#v%s\n", *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmErrorf.t.Errorf("TesterMock.Errorf got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorf.t.Errorf("TesterMock.Errorf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(format, args...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to TesterMock.Errorf. %v %v", format, args)

}

// ErrorfAfterCounter returns a count of finished TesterMock.Errorf invocations
func (mmErrorf *TesterMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of TesterMock.Errorf invocations
func (mmErrorf *TesterMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to TesterMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mTesterMockErrorf) Calls() []*TesterMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*TesterMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *TesterMock) MinimockErrorfDone() bool {
	if m.ErrorfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorfMock.invocationsDone()
}

// MinimockErrorfInspect logs each unmet expectation
func (m *TesterMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TesterMock.Errorf with params: %#v", *e.params)
		}
	}

	afterErrorfCounter := mm_atomic.LoadUint64(&m.afterErrorfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && afterErrorfCounter < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TesterMock.Errorf")
		} else {
			m.t.Errorf("Expected call to TesterMock.Errorf with params: %#v", *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && afterErrorfCounter < 1 {
		m.t.Error("Expected call to TesterMock.Errorf")
	}

	if !m.ErrorfMock.invocationsDone() && afterErrorfCounter > 0 {
		m.t.Errorf("Expected %d calls to TesterMock.Errorf but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorfMock.expectedInvocations), afterErrorfCounter)
	}
}

type mTesterMockFailNow struct {
	optional           bool
	mock               *TesterMock
	defaultExpectation *TesterMockFailNowExpectation
	expectations       []*TesterMockFailNowExpectation

	expectedInvocations uint64
}

// TesterMockFailNowExpectation specifies expectation struct of the Tester.FailNow
type TesterMockFailNowExpectation struct {
	mock *TesterMock

	Counter uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFailNow *mTesterMockFailNow) Optional() *mTesterMockFailNow {
	mmFailNow.optional = true
	return mmFailNow
}

// Expect sets up expected params for Tester.FailNow
func (mmFailNow *mTesterMockFailNow) Expect() *mTesterMockFailNow {
	if mmFailNow.mock.funcFailNow != nil {
		mmFailNow.mock.t.Fatalf("TesterMock.FailNow mock is already set by Set")
	}

	if mmFailNow.defaultExpectation == nil {
		mmFailNow.defaultExpectation = &TesterMockFailNowExpectation{}
	}

	return mmFailNow
}

// Inspect accepts an inspector function that has same arguments as the Tester.FailNow
func (mmFailNow *mTesterMockFailNow) Inspect(f func()) *mTesterMockFailNow {
	if mmFailNow.mock.inspectFuncFailNow != nil {
		mmFailNow.mock.t.Fatalf("Inspect function is already set for TesterMock.FailNow")
	}

	mmFailNow.mock.inspectFuncFailNow = f

	return mmFailNow
}

// Return sets up results that will be returned by Tester.FailNow
func (mmFailNow *mTesterMockFailNow) Return() *TesterMock {
	if mmFailNow.mock.funcFailNow != nil {
		mmFailNow.mock.t.Fatalf("TesterMock.FailNow mock is already set by Set")
	}

	if mmFailNow.defaultExpectation == nil {
		mmFailNow.defaultExpectation = &TesterMockFailNowExpectation{mock: mmFailNow.mock}
	}

	return mmFailNow.mock
}

// Set uses given function f to mock the Tester.FailNow method
func (mmFailNow *mTesterMockFailNow) Set(f func()) *TesterMock {
	if mmFailNow.defaultExpectation != nil {
		mmFailNow.mock.t.Fatalf("Default expectation is already set for the Tester.FailNow method")
	}

	if len(mmFailNow.expectations) > 0 {
		mmFailNow.mock.t.Fatalf("Some expectations are already set for the Tester.FailNow method")
	}

	mmFailNow.mock.funcFailNow = f
	return mmFailNow.mock
}

// Times sets number of times Tester.FailNow should be invoked
func (mmFailNow *mTesterMockFailNow) Times(n uint64) *mTesterMockFailNow {
	if n == 0 {
		mmFailNow.mock.t.Fatalf("Times of TesterMock.FailNow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFailNow.expectedInvocations, n)
	return mmFailNow
}

func (mmFailNow *mTesterMockFailNow) invocationsDone() bool {
	if len(mmFailNow.expectations) == 0 && mmFailNow.defaultExpectation == nil && mmFailNow.mock.funcFailNow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFailNow.mock.afterFailNowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFailNow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FailNow implements minimock.Tester
func (mmFailNow *TesterMock) FailNow() {
	mm_atomic.AddUint64(&mmFailNow.beforeFailNowCounter, 1)
	defer mm_atomic.AddUint64(&mmFailNow.afterFailNowCounter, 1)

	if mmFailNow.inspectFuncFailNow != nil {
		mmFailNow.inspectFuncFailNow()
	}

	if mmFailNow.FailNowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFailNow.FailNowMock.defaultExpectation.Counter, 1)

		return

	}
	if mmFailNow.funcFailNow != nil {
		mmFailNow.funcFailNow()
		return
	}
	mmFailNow.t.Fatalf("Unexpected call to TesterMock.FailNow.")

}

// FailNowAfterCounter returns a count of finished TesterMock.FailNow invocations
func (mmFailNow *TesterMock) FailNowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFailNow.afterFailNowCounter)
}

// FailNowBeforeCounter returns a count of TesterMock.FailNow invocations
func (mmFailNow *TesterMock) FailNowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFailNow.beforeFailNowCounter)
}

// MinimockFailNowDone returns true if the count of the FailNow invocations corresponds
// the number of defined expectations
func (m *TesterMock) MinimockFailNowDone() bool {
	if m.FailNowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FailNowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FailNowMock.invocationsDone()
}

// MinimockFailNowInspect logs each unmet expectation
func (m *TesterMock) MinimockFailNowInspect() {
	for _, e := range m.FailNowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TesterMock.FailNow")
		}
	}

	afterFailNowCounter := mm_atomic.LoadUint64(&m.afterFailNowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FailNowMock.defaultExpectation != nil && afterFailNowCounter < 1 {
		m.t.Error("Expected call to TesterMock.FailNow")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFailNow != nil && afterFailNowCounter < 1 {
		m.t.Error("Expected call to TesterMock.FailNow")
	}

	if !m.FailNowMock.invocationsDone() && afterFailNowCounter > 0 {
		m.t.Errorf("Expected %d calls to TesterMock.FailNow but found %d calls",
			mm_atomic.LoadUint64(&m.FailNowMock.expectedInvocations), afterFailNowCounter)
	}
}

type mTesterMockFatal struct {
	optional           bool
	mock               *TesterMock
	defaultExpectation *TesterMockFatalExpectation
	expectations       []*TesterMockFatalExpectation

	callArgs []*TesterMockFatalParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TesterMockFatalExpectation specifies expectation struct of the Tester.Fatal
type TesterMockFatalExpectation struct {
	mock      *TesterMock
	params    *TesterMockFatalParams
	paramPtrs *TesterMockFatalParamPtrs

	Counter uint64
}

// TesterMockFatalParams contains parameters of the Tester.Fatal
type TesterMockFatalParams struct {
	args []interface{}
}

// TesterMockFatalParamPtrs contains pointers to parameters of the Tester.Fatal
type TesterMockFatalParamPtrs struct {
	args *[]interface{}
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFatal *mTesterMockFatal) Optional() *mTesterMockFatal {
	mmFatal.optional = true
	return mmFatal
}

// Expect sets up expected params for Tester.Fatal
func (mmFatal *mTesterMockFatal) Expect(args ...interface{}) *mTesterMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("TesterMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &TesterMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.paramPtrs != nil {
		mmFatal.mock.t.Fatalf("TesterMock.Fatal mock is already set by ExpectParams functions")
	}

	mmFatal.defaultExpectation.params = &TesterMockFatalParams{args}
	for _, e := range mmFatal.expectations {
		if minimock.Equal(e.params, mmFatal.defaultExpectation.params) {
			mmFatal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatal.defaultExpectation.params)
		}
	}

	return mmFatal
}

// ExpectArgsParam1 sets up expected param args for Tester.Fatal
func (mmFatal *mTesterMockFatal) ExpectArgsParam1(args ...interface{}) *mTesterMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("TesterMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &TesterMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.params != nil {
		mmFatal.mock.t.Fatalf("TesterMock.Fatal mock is already set by Expect")
	}

	if mmFatal.defaultExpectation.paramPtrs == nil {
		mmFatal.defaultExpectation.paramPtrs = &TesterMockFatalParamPtrs{}
	}
	mmFatal.defaultExpectation.paramPtrs.args = &args

	return mmFatal
}

// Inspect accepts an inspector function that has same arguments as the Tester.Fatal
func (mmFatal *mTesterMockFatal) Inspect(f func(args ...interface{})) *mTesterMockFatal {
	if mmFatal.mock.inspectFuncFatal != nil {
		mmFatal.mock.t.Fatalf("Inspect function is already set for TesterMock.Fatal")
	}

	mmFatal.mock.inspectFuncFatal = f

	return mmFatal
}

// Return sets up results that will be returned by Tester.Fatal
func (mmFatal *mTesterMockFatal) Return() *TesterMock {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("TesterMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &TesterMockFatalExpectation{mock: mmFatal.mock}
	}

	return mmFatal.mock
}

// Set uses given function f to mock the Tester.Fatal method
func (mmFatal *mTesterMockFatal) Set(f func(args ...interface{})) *TesterMock {
	if mmFatal.defaultExpectation != nil {
		mmFatal.mock.t.Fatalf("Default expectation is already set for the Tester.Fatal method")
	}

	if len(mmFatal.expectations) > 0 {
		mmFatal.mock.t.Fatalf("Some expectations are already set for the Tester.Fatal method")
	}

	mmFatal.mock.funcFatal = f
	return mmFatal.mock
}

// Times sets number of times Tester.Fatal should be invoked
func (mmFatal *mTesterMockFatal) Times(n uint64) *mTesterMockFatal {
	if n == 0 {
		mmFatal.mock.t.Fatalf("Times of TesterMock.Fatal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFatal.expectedInvocations, n)
	return mmFatal
}

func (mmFatal *mTesterMockFatal) invocationsDone() bool {
	if len(mmFatal.expectations) == 0 && mmFatal.defaultExpectation == nil && mmFatal.mock.funcFatal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFatal.mock.afterFatalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFatal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fatal implements minimock.Tester
func (mmFatal *TesterMock) Fatal(args ...interface{}) {
	mm_atomic.AddUint64(&mmFatal.beforeFatalCounter, 1)
	defer mm_atomic.AddUint64(&mmFatal.afterFatalCounter, 1)

	if mmFatal.inspectFuncFatal != nil {
		mmFatal.inspectFuncFatal(args...)
	}

	mm_params := TesterMockFatalParams{args}

	// Record call args
	mmFatal.FatalMock.mutex.Lock()
	mmFatal.FatalMock.callArgs = append(mmFatal.FatalMock.callArgs, &mm_params)
	mmFatal.FatalMock.mutex.Unlock()

	for _, e := range mmFatal.FatalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatal.FatalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatal.FatalMock.defaultExpectation.Counter, 1)
		mm_want := mmFatal.FatalMock.defaultExpectation.params
		mm_want_ptrs := mmFatal.FatalMock.defaultExpectation.paramPtrs

		mm_got := TesterMockFatalParams{args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmFatal.t.Errorf("TesterMock.Fatal got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatal.t.Errorf("TesterMock.Fatal got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatal.funcFatal != nil {
		mmFatal.funcFatal(args...)
		return
	}
	mmFatal.t.Fatalf("Unexpected call to TesterMock.Fatal. %v", args)

}

// FatalAfterCounter returns a count of finished TesterMock.Fatal invocations
func (mmFatal *TesterMock) FatalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.afterFatalCounter)
}

// FatalBeforeCounter returns a count of TesterMock.Fatal invocations
func (mmFatal *TesterMock) FatalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.beforeFatalCounter)
}

// Calls returns a list of arguments used in each call to TesterMock.Fatal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatal *mTesterMockFatal) Calls() []*TesterMockFatalParams {
	mmFatal.mutex.RLock()

	argCopy := make([]*TesterMockFatalParams, len(mmFatal.callArgs))
	copy(argCopy, mmFatal.callArgs)

	mmFatal.mutex.RUnlock()

	return argCopy
}

// MinimockFatalDone returns true if the count of the Fatal invocations corresponds
// the number of defined expectations
func (m *TesterMock) MinimockFatalDone() bool {
	if m.FatalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FatalMock.invocationsDone()
}

// MinimockFatalInspect logs each unmet expectation
func (m *TesterMock) MinimockFatalInspect() {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TesterMock.Fatal with params: %#v", *e.params)
		}
	}

	afterFatalCounter := mm_atomic.LoadUint64(&m.afterFatalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && afterFatalCounter < 1 {
		if m.FatalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TesterMock.Fatal")
		} else {
			m.t.Errorf("Expected call to TesterMock.Fatal with params: %#v", *m.FatalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && afterFatalCounter < 1 {
		m.t.Error("Expected call to TesterMock.Fatal")
	}

	if !m.FatalMock.invocationsDone() && afterFatalCounter > 0 {
		m.t.Errorf("Expected %d calls to TesterMock.Fatal but found %d calls",
			mm_atomic.LoadUint64(&m.FatalMock.expectedInvocations), afterFatalCounter)
	}
}

type mTesterMockFatalf struct {
	optional           bool
	mock               *TesterMock
	defaultExpectation *TesterMockFatalfExpectation
	expectations       []*TesterMockFatalfExpectation

	callArgs []*TesterMockFatalfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TesterMockFatalfExpectation specifies expectation struct of the Tester.Fatalf
type TesterMockFatalfExpectation struct {
	mock      *TesterMock
	params    *TesterMockFatalfParams
	paramPtrs *TesterMockFatalfParamPtrs

	Counter uint64
}

// TesterMockFatalfParams contains parameters of the Tester.Fatalf
type TesterMockFatalfParams struct {
	format string
	args   []interface{}
}

// TesterMockFatalfParamPtrs contains pointers to parameters of the Tester.Fatalf
type TesterMockFatalfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFatalf *mTesterMockFatalf) Optional() *mTesterMockFatalf {
	mmFatalf.optional = true
	return mmFatalf
}

// Expect sets up expected params for Tester.Fatalf
func (mmFatalf *mTesterMockFatalf) Expect(format string, args ...interface{}) *mTesterMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("TesterMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &TesterMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.paramPtrs != nil {
		mmFatalf.mock.t.Fatalf("TesterMock.Fatalf mock is already set by ExpectParams functions")
	}

	mmFatalf.defaultExpectation.params = &TesterMockFatalfParams{format, args}
	for _, e := range mmFatalf.expectations {
		if minimock.Equal(e.params, mmFatalf.defaultExpectation.params) {
			mmFatalf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatalf.defaultExpectation.params)
		}
	}

	return mmFatalf
}

// ExpectFormatParam1 sets up expected param format for Tester.Fatalf
func (mmFatalf *mTesterMockFatalf) ExpectFormatParam1(format string) *mTesterMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("TesterMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &TesterMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.params != nil {
		mmFatalf.mock.t.Fatalf("TesterMock.Fatalf mock is already set by Expect")
	}

	if mmFatalf.defaultExpectation.paramPtrs == nil {
		mmFatalf.defaultExpectation.paramPtrs = &TesterMockFatalfParamPtrs{}
	}
	mmFatalf.defaultExpectation.paramPtrs.format = &format

	return mmFatalf
}

// ExpectArgsParam2 sets up expected param args for Tester.Fatalf
func (mmFatalf *mTesterMockFatalf) ExpectArgsParam2(args ...interface{}) *mTesterMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("TesterMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &TesterMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.params != nil {
		mmFatalf.mock.t.Fatalf("TesterMock.Fatalf mock is already set by Expect")
	}

	if mmFatalf.defaultExpectation.paramPtrs == nil {
		mmFatalf.defaultExpectation.paramPtrs = &TesterMockFatalfParamPtrs{}
	}
	mmFatalf.defaultExpectation.paramPtrs.args = &args

	return mmFatalf
}

// Inspect accepts an inspector function that has same arguments as the Tester.Fatalf
func (mmFatalf *mTesterMockFatalf) Inspect(f func(format string, args ...interface{})) *mTesterMockFatalf {
	if mmFatalf.mock.inspectFuncFatalf != nil {
		mmFatalf.mock.t.Fatalf("Inspect function is already set for TesterMock.Fatalf")
	}

	mmFatalf.mock.inspectFuncFatalf = f

	return mmFatalf
}

// Return sets up results that will be returned by Tester.Fatalf
func (mmFatalf *mTesterMockFatalf) Return() *TesterMock {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("TesterMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &TesterMockFatalfExpectation{mock: mmFatalf.mock}
	}

	return mmFatalf.mock
}

// Set uses given function f to mock the Tester.Fatalf method
func (mmFatalf *mTesterMockFatalf) Set(f func(format string, args ...interface{})) *TesterMock {
	if mmFatalf.defaultExpectation != nil {
		mmFatalf.mock.t.Fatalf("Default expectation is already set for the Tester.Fatalf method")
	}

	if len(mmFatalf.expectations) > 0 {
		mmFatalf.mock.t.Fatalf("Some expectations are already set for the Tester.Fatalf method")
	}

	mmFatalf.mock.funcFatalf = f
	return mmFatalf.mock
}

// Times sets number of times Tester.Fatalf should be invoked
func (mmFatalf *mTesterMockFatalf) Times(n uint64) *mTesterMockFatalf {
	if n == 0 {
		mmFatalf.mock.t.Fatalf("Times of TesterMock.Fatalf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFatalf.expectedInvocations, n)
	return mmFatalf
}

func (mmFatalf *mTesterMockFatalf) invocationsDone() bool {
	if len(mmFatalf.expectations) == 0 && mmFatalf.defaultExpectation == nil && mmFatalf.mock.funcFatalf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFatalf.mock.afterFatalfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFatalf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fatalf implements minimock.Tester
func (mmFatalf *TesterMock) Fatalf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmFatalf.beforeFatalfCounter, 1)
	defer mm_atomic.AddUint64(&mmFatalf.afterFatalfCounter, 1)

	if mmFatalf.inspectFuncFatalf != nil {
		mmFatalf.inspectFuncFatalf(format, args...)
	}

	mm_params := TesterMockFatalfParams{format, args}

	// Record call args
	mmFatalf.FatalfMock.mutex.Lock()
	mmFatalf.FatalfMock.callArgs = append(mmFatalf.FatalfMock.callArgs, &mm_params)
	mmFatalf.FatalfMock.mutex.Unlock()

	for _, e := range mmFatalf.FatalfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatalf.FatalfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatalf.FatalfMock.defaultExpectation.Counter, 1)
		mm_want := mmFatalf.FatalfMock.defaultExpectation.params
		mm_want_ptrs := mmFatalf.FatalfMock.defaultExpectation.paramPtrs

		mm_got := TesterMockFatalfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmFatalf.t.Errorf("TesterMock.Fatalf got unexpected parameter format, want: %#v, got: %#v%s\n", *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmFatalf.t.Errorf("TesterMock.Fatalf got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatalf.t.Errorf("TesterMock.Fatalf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatalf.funcFatalf != nil {
		mmFatalf.funcFatalf(format, args...)
		return
	}
	mmFatalf.t.Fatalf("Unexpected call to TesterMock.Fatalf. %v %v", format, args)

}

// FatalfAfterCounter returns a count of finished TesterMock.Fatalf invocations
func (mmFatalf *TesterMock) FatalfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.afterFatalfCounter)
}

// FatalfBeforeCounter returns a count of TesterMock.Fatalf invocations
func (mmFatalf *TesterMock) FatalfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.beforeFatalfCounter)
}

// Calls returns a list of arguments used in each call to TesterMock.Fatalf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatalf *mTesterMockFatalf) Calls() []*TesterMockFatalfParams {
	mmFatalf.mutex.RLock()

	argCopy := make([]*TesterMockFatalfParams, len(mmFatalf.callArgs))
	copy(argCopy, mmFatalf.callArgs)

	mmFatalf.mutex.RUnlock()

	return argCopy
}

// MinimockFatalfDone returns true if the count of the Fatalf invocations corresponds
// the number of defined expectations
func (m *TesterMock) MinimockFatalfDone() bool {
	if m.FatalfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FatalfMock.invocationsDone()
}

// MinimockFatalfInspect logs each unmet expectation
func (m *TesterMock) MinimockFatalfInspect() {
	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TesterMock.Fatalf with params: %#v", *e.params)
		}
	}

	afterFatalfCounter := mm_atomic.LoadUint64(&m.afterFatalfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FatalfMock.defaultExpectation != nil && afterFatalfCounter < 1 {
		if m.FatalfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TesterMock.Fatalf")
		} else {
			m.t.Errorf("Expected call to TesterMock.Fatalf with params: %#v", *m.FatalfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatalf != nil && afterFatalfCounter < 1 {
		m.t.Error("Expected call to TesterMock.Fatalf")
	}

	if !m.FatalfMock.invocationsDone() && afterFatalfCounter > 0 {
		m.t.Errorf("Expected %d calls to TesterMock.Fatalf but found %d calls",
			mm_atomic.LoadUint64(&m.FatalfMock.expectedInvocations), afterFatalfCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TesterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCleanupInspect()

			m.MinimockErrorInspect()

			m.MinimockErrorfInspect()

			m.MinimockFailNowInspect()

			m.MinimockFatalInspect()

			m.MinimockFatalfInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TesterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TesterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCleanupDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockFailNowDone() &&
		m.MinimockFatalDone() &&
		m.MinimockFatalfDone()
}
