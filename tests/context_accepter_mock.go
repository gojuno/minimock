// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package tests

//go:generate minimock -i github.com/gojuno/minimock/v3/tests.contextAccepter -o context_accepter_mock.go -n ContextAccepterMock -p tests

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ContextAccepterMock implements contextAccepter
type ContextAccepterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcceptContext          func(ctx context.Context)
	funcAcceptContextOrigin    string
	inspectFuncAcceptContext   func(ctx context.Context)
	afterAcceptContextCounter  uint64
	beforeAcceptContextCounter uint64
	AcceptContextMock          mContextAccepterMockAcceptContext

	funcAcceptContextWithOtherArgs          func(ctx context.Context, i1 int) (i2 int, err error)
	funcAcceptContextWithOtherArgsOrigin    string
	inspectFuncAcceptContextWithOtherArgs   func(ctx context.Context, i1 int)
	afterAcceptContextWithOtherArgsCounter  uint64
	beforeAcceptContextWithOtherArgsCounter uint64
	AcceptContextWithOtherArgsMock          mContextAccepterMockAcceptContextWithOtherArgs

	funcAcceptContextWithStructArgs          func(ctx context.Context, s1 structArg) (i1 int, err error)
	funcAcceptContextWithStructArgsOrigin    string
	inspectFuncAcceptContextWithStructArgs   func(ctx context.Context, s1 structArg)
	afterAcceptContextWithStructArgsCounter  uint64
	beforeAcceptContextWithStructArgsCounter uint64
	AcceptContextWithStructArgsMock          mContextAccepterMockAcceptContextWithStructArgs
}

// NewContextAccepterMock returns a mock for contextAccepter
func NewContextAccepterMock(t minimock.Tester) *ContextAccepterMock {
	m := &ContextAccepterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptContextMock = mContextAccepterMockAcceptContext{mock: m}
	m.AcceptContextMock.callArgs = []*ContextAccepterMockAcceptContextParams{}

	m.AcceptContextWithOtherArgsMock = mContextAccepterMockAcceptContextWithOtherArgs{mock: m}
	m.AcceptContextWithOtherArgsMock.callArgs = []*ContextAccepterMockAcceptContextWithOtherArgsParams{}

	m.AcceptContextWithStructArgsMock = mContextAccepterMockAcceptContextWithStructArgs{mock: m}
	m.AcceptContextWithStructArgsMock.callArgs = []*ContextAccepterMockAcceptContextWithStructArgsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mContextAccepterMockAcceptContext struct {
	optional           bool
	mock               *ContextAccepterMock
	defaultExpectation *ContextAccepterMockAcceptContextExpectation
	expectations       []*ContextAccepterMockAcceptContextExpectation

	callArgs []*ContextAccepterMockAcceptContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ContextAccepterMockAcceptContextExpectation specifies expectation struct of the contextAccepter.AcceptContext
type ContextAccepterMockAcceptContextExpectation struct {
	mock               *ContextAccepterMock
	params             *ContextAccepterMockAcceptContextParams
	paramPtrs          *ContextAccepterMockAcceptContextParamPtrs
	expectationOrigins ContextAccepterMockAcceptContextExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// ContextAccepterMockAcceptContextParams contains parameters of the contextAccepter.AcceptContext
type ContextAccepterMockAcceptContextParams struct {
	ctx context.Context
}

// ContextAccepterMockAcceptContextParamPtrs contains pointers to parameters of the contextAccepter.AcceptContext
type ContextAccepterMockAcceptContextParamPtrs struct {
	ctx *context.Context
}

// ContextAccepterMockAcceptContextOrigins contains origins of expectations of the contextAccepter.AcceptContext
type ContextAccepterMockAcceptContextExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptContext *mContextAccepterMockAcceptContext) Optional() *mContextAccepterMockAcceptContext {
	mmAcceptContext.optional = true
	return mmAcceptContext
}

// Expect sets up expected params for contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) Expect(ctx context.Context) *mContextAccepterMockAcceptContext {
	if mmAcceptContext.mock.funcAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Set")
	}

	if mmAcceptContext.defaultExpectation == nil {
		mmAcceptContext.defaultExpectation = &ContextAccepterMockAcceptContextExpectation{}
	}

	if mmAcceptContext.defaultExpectation.paramPtrs != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by ExpectParams functions")
	}

	mmAcceptContext.defaultExpectation.params = &ContextAccepterMockAcceptContextParams{ctx}
	mmAcceptContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptContext.expectations {
		if minimock.Equal(e.params, mmAcceptContext.defaultExpectation.params) {
			mmAcceptContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptContext.defaultExpectation.params)
		}
	}

	return mmAcceptContext
}

// ExpectCtxParam1 sets up expected param ctx for contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) ExpectCtxParam1(ctx context.Context) *mContextAccepterMockAcceptContext {
	if mmAcceptContext.mock.funcAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Set")
	}

	if mmAcceptContext.defaultExpectation == nil {
		mmAcceptContext.defaultExpectation = &ContextAccepterMockAcceptContextExpectation{}
	}

	if mmAcceptContext.defaultExpectation.params != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Expect")
	}

	if mmAcceptContext.defaultExpectation.paramPtrs == nil {
		mmAcceptContext.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextParamPtrs{}
	}
	mmAcceptContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmAcceptContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAcceptContext
}

// Inspect accepts an inspector function that has same arguments as the contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) Inspect(f func(ctx context.Context)) *mContextAccepterMockAcceptContext {
	if mmAcceptContext.mock.inspectFuncAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("Inspect function is already set for ContextAccepterMock.AcceptContext")
	}

	mmAcceptContext.mock.inspectFuncAcceptContext = f

	return mmAcceptContext
}

// Return sets up results that will be returned by contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) Return() *ContextAccepterMock {
	if mmAcceptContext.mock.funcAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Set")
	}

	if mmAcceptContext.defaultExpectation == nil {
		mmAcceptContext.defaultExpectation = &ContextAccepterMockAcceptContextExpectation{mock: mmAcceptContext.mock}
	}

	mmAcceptContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptContext.mock
}

// Set uses given function f to mock the contextAccepter.AcceptContext method
func (mmAcceptContext *mContextAccepterMockAcceptContext) Set(f func(ctx context.Context)) *ContextAccepterMock {
	if mmAcceptContext.defaultExpectation != nil {
		mmAcceptContext.mock.t.Fatalf("Default expectation is already set for the contextAccepter.AcceptContext method")
	}

	if len(mmAcceptContext.expectations) > 0 {
		mmAcceptContext.mock.t.Fatalf("Some expectations are already set for the contextAccepter.AcceptContext method")
	}

	mmAcceptContext.mock.funcAcceptContext = f
	mmAcceptContext.mock.funcAcceptContextOrigin = minimock.CallerInfo(1)
	return mmAcceptContext.mock
}

// When sets expectation for the contextAccepter.AcceptContext which will trigger the result defined by the following
// Then helper
func (mmAcceptContext *mContextAccepterMockAcceptContext) When(ctx context.Context) *ContextAccepterMockAcceptContextExpectation {
	if mmAcceptContext.mock.funcAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Set")
	}

	expectation := &ContextAccepterMockAcceptContextExpectation{
		mock:               mmAcceptContext.mock,
		params:             &ContextAccepterMockAcceptContextParams{ctx},
		expectationOrigins: ContextAccepterMockAcceptContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptContext.expectations = append(mmAcceptContext.expectations, expectation)
	return expectation
}

// Then sets up contextAccepter.AcceptContext return parameters for the expectation previously defined by the When method

func (e *ContextAccepterMockAcceptContextExpectation) Then() *ContextAccepterMock {
	return e.mock
}

// Times sets number of times contextAccepter.AcceptContext should be invoked
func (mmAcceptContext *mContextAccepterMockAcceptContext) Times(n uint64) *mContextAccepterMockAcceptContext {
	if n == 0 {
		mmAcceptContext.mock.t.Fatalf("Times of ContextAccepterMock.AcceptContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptContext.expectedInvocations, n)
	mmAcceptContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptContext
}

func (mmAcceptContext *mContextAccepterMockAcceptContext) invocationsDone() bool {
	if len(mmAcceptContext.expectations) == 0 && mmAcceptContext.defaultExpectation == nil && mmAcceptContext.mock.funcAcceptContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptContext.mock.afterAcceptContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptContext implements contextAccepter
func (mmAcceptContext *ContextAccepterMock) AcceptContext(ctx context.Context) {
	mm_atomic.AddUint64(&mmAcceptContext.beforeAcceptContextCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptContext.afterAcceptContextCounter, 1)

	mmAcceptContext.t.Helper()

	if mmAcceptContext.inspectFuncAcceptContext != nil {
		mmAcceptContext.inspectFuncAcceptContext(ctx)
	}

	mm_params := ContextAccepterMockAcceptContextParams{ctx}

	// Record call args
	mmAcceptContext.AcceptContextMock.mutex.Lock()
	mmAcceptContext.AcceptContextMock.callArgs = append(mmAcceptContext.AcceptContextMock.callArgs, &mm_params)
	mmAcceptContext.AcceptContextMock.mutex.Unlock()

	for _, e := range mmAcceptContext.AcceptContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAcceptContext.AcceptContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptContext.AcceptContextMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptContext.AcceptContextMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptContext.AcceptContextMock.defaultExpectation.paramPtrs

		mm_got := ContextAccepterMockAcceptContextParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptContext.t.Errorf("ContextAccepterMock.AcceptContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptContext.AcceptContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptContext.t.Errorf("ContextAccepterMock.AcceptContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptContext.AcceptContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAcceptContext.funcAcceptContext != nil {
		mmAcceptContext.funcAcceptContext(ctx)
		return
	}
	mmAcceptContext.t.Fatalf("Unexpected call to ContextAccepterMock.AcceptContext. %v", ctx)

}

// AcceptContextAfterCounter returns a count of finished ContextAccepterMock.AcceptContext invocations
func (mmAcceptContext *ContextAccepterMock) AcceptContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContext.afterAcceptContextCounter)
}

// AcceptContextBeforeCounter returns a count of ContextAccepterMock.AcceptContext invocations
func (mmAcceptContext *ContextAccepterMock) AcceptContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContext.beforeAcceptContextCounter)
}

// Calls returns a list of arguments used in each call to ContextAccepterMock.AcceptContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptContext *mContextAccepterMockAcceptContext) Calls() []*ContextAccepterMockAcceptContextParams {
	mmAcceptContext.mutex.RLock()

	argCopy := make([]*ContextAccepterMockAcceptContextParams, len(mmAcceptContext.callArgs))
	copy(argCopy, mmAcceptContext.callArgs)

	mmAcceptContext.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptContextDone returns true if the count of the AcceptContext invocations corresponds
// the number of defined expectations
func (m *ContextAccepterMock) MinimockAcceptContextDone() bool {
	if m.AcceptContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptContextMock.invocationsDone()
}

// MinimockAcceptContextInspect logs each unmet expectation
func (m *ContextAccepterMock) MinimockAcceptContextInspect() {
	for _, e := range m.AcceptContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptContextCounter := mm_atomic.LoadUint64(&m.afterAcceptContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextMock.defaultExpectation != nil && afterAcceptContextCounter < 1 {
		if m.AcceptContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContext at\n%s", m.AcceptContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContext at\n%s with params: %#v", m.AcceptContextMock.defaultExpectation.expectationOrigins.origin, *m.AcceptContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContext != nil && afterAcceptContextCounter < 1 {
		m.t.Errorf("Expected call to ContextAccepterMock.AcceptContext at\n%s", m.funcAcceptContextOrigin)
	}

	if !m.AcceptContextMock.invocationsDone() && afterAcceptContextCounter > 0 {
		m.t.Errorf("Expected %d calls to ContextAccepterMock.AcceptContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptContextMock.expectedInvocations), m.AcceptContextMock.expectedInvocationsOrigin, afterAcceptContextCounter)
	}
}

type mContextAccepterMockAcceptContextWithOtherArgs struct {
	optional           bool
	mock               *ContextAccepterMock
	defaultExpectation *ContextAccepterMockAcceptContextWithOtherArgsExpectation
	expectations       []*ContextAccepterMockAcceptContextWithOtherArgsExpectation

	callArgs []*ContextAccepterMockAcceptContextWithOtherArgsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ContextAccepterMockAcceptContextWithOtherArgsExpectation specifies expectation struct of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsExpectation struct {
	mock               *ContextAccepterMock
	params             *ContextAccepterMockAcceptContextWithOtherArgsParams
	paramPtrs          *ContextAccepterMockAcceptContextWithOtherArgsParamPtrs
	expectationOrigins ContextAccepterMockAcceptContextWithOtherArgsExpectationOrigins
	results            *ContextAccepterMockAcceptContextWithOtherArgsResults
	returnOrigin       string
	Counter            uint64
}

// ContextAccepterMockAcceptContextWithOtherArgsParams contains parameters of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsParams struct {
	ctx context.Context
	i1  int
}

// ContextAccepterMockAcceptContextWithOtherArgsParamPtrs contains pointers to parameters of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsParamPtrs struct {
	ctx *context.Context
	i1  *int
}

// ContextAccepterMockAcceptContextWithOtherArgsResults contains results of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsResults struct {
	i2  int
	err error
}

// ContextAccepterMockAcceptContextWithOtherArgsOrigins contains origins of expectations of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsExpectationOrigins struct {
	origin    string
	originCtx string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Optional() *mContextAccepterMockAcceptContextWithOtherArgs {
	mmAcceptContextWithOtherArgs.optional = true
	return mmAcceptContextWithOtherArgs
}

// Expect sets up expected params for contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Expect(ctx context.Context, i1 int) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{}
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by ExpectParams functions")
	}

	mmAcceptContextWithOtherArgs.defaultExpectation.params = &ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1}
	mmAcceptContextWithOtherArgs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptContextWithOtherArgs.expectations {
		if minimock.Equal(e.params, mmAcceptContextWithOtherArgs.defaultExpectation.params) {
			mmAcceptContextWithOtherArgs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptContextWithOtherArgs.defaultExpectation.params)
		}
	}

	return mmAcceptContextWithOtherArgs
}

// ExpectCtxParam1 sets up expected param ctx for contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) ExpectCtxParam1(ctx context.Context) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{}
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.params != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Expect")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextWithOtherArgsParamPtrs{}
	}
	mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs.ctx = &ctx
	mmAcceptContextWithOtherArgs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAcceptContextWithOtherArgs
}

// ExpectI1Param2 sets up expected param i1 for contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) ExpectI1Param2(i1 int) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{}
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.params != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Expect")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextWithOtherArgsParamPtrs{}
	}
	mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs.i1 = &i1
	mmAcceptContextWithOtherArgs.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmAcceptContextWithOtherArgs
}

// Inspect accepts an inspector function that has same arguments as the contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Inspect(f func(ctx context.Context, i1 int)) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.inspectFuncAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Inspect function is already set for ContextAccepterMock.AcceptContextWithOtherArgs")
	}

	mmAcceptContextWithOtherArgs.mock.inspectFuncAcceptContextWithOtherArgs = f

	return mmAcceptContextWithOtherArgs
}

// Return sets up results that will be returned by contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Return(i2 int, err error) *ContextAccepterMock {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{mock: mmAcceptContextWithOtherArgs.mock}
	}
	mmAcceptContextWithOtherArgs.defaultExpectation.results = &ContextAccepterMockAcceptContextWithOtherArgsResults{i2, err}
	mmAcceptContextWithOtherArgs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptContextWithOtherArgs.mock
}

// Set uses given function f to mock the contextAccepter.AcceptContextWithOtherArgs method
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Set(f func(ctx context.Context, i1 int) (i2 int, err error)) *ContextAccepterMock {
	if mmAcceptContextWithOtherArgs.defaultExpectation != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Default expectation is already set for the contextAccepter.AcceptContextWithOtherArgs method")
	}

	if len(mmAcceptContextWithOtherArgs.expectations) > 0 {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Some expectations are already set for the contextAccepter.AcceptContextWithOtherArgs method")
	}

	mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs = f
	mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgsOrigin = minimock.CallerInfo(1)
	return mmAcceptContextWithOtherArgs.mock
}

// When sets expectation for the contextAccepter.AcceptContextWithOtherArgs which will trigger the result defined by the following
// Then helper
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) When(ctx context.Context, i1 int) *ContextAccepterMockAcceptContextWithOtherArgsExpectation {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	expectation := &ContextAccepterMockAcceptContextWithOtherArgsExpectation{
		mock:               mmAcceptContextWithOtherArgs.mock,
		params:             &ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1},
		expectationOrigins: ContextAccepterMockAcceptContextWithOtherArgsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptContextWithOtherArgs.expectations = append(mmAcceptContextWithOtherArgs.expectations, expectation)
	return expectation
}

// Then sets up contextAccepter.AcceptContextWithOtherArgs return parameters for the expectation previously defined by the When method
func (e *ContextAccepterMockAcceptContextWithOtherArgsExpectation) Then(i2 int, err error) *ContextAccepterMock {
	e.results = &ContextAccepterMockAcceptContextWithOtherArgsResults{i2, err}
	return e.mock
}

// Times sets number of times contextAccepter.AcceptContextWithOtherArgs should be invoked
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Times(n uint64) *mContextAccepterMockAcceptContextWithOtherArgs {
	if n == 0 {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Times of ContextAccepterMock.AcceptContextWithOtherArgs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptContextWithOtherArgs.expectedInvocations, n)
	mmAcceptContextWithOtherArgs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptContextWithOtherArgs
}

func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) invocationsDone() bool {
	if len(mmAcceptContextWithOtherArgs.expectations) == 0 && mmAcceptContextWithOtherArgs.defaultExpectation == nil && mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.mock.afterAcceptContextWithOtherArgsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptContextWithOtherArgs implements contextAccepter
func (mmAcceptContextWithOtherArgs *ContextAccepterMock) AcceptContextWithOtherArgs(ctx context.Context, i1 int) (i2 int, err error) {
	mm_atomic.AddUint64(&mmAcceptContextWithOtherArgs.beforeAcceptContextWithOtherArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptContextWithOtherArgs.afterAcceptContextWithOtherArgsCounter, 1)

	mmAcceptContextWithOtherArgs.t.Helper()

	if mmAcceptContextWithOtherArgs.inspectFuncAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.inspectFuncAcceptContextWithOtherArgs(ctx, i1)
	}

	mm_params := ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1}

	// Record call args
	mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.mutex.Lock()
	mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.callArgs = append(mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.callArgs, &mm_params)
	mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.mutex.Unlock()

	for _, e := range mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i2, e.results.err
		}
	}

	if mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.paramPtrs

		mm_got := ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptContextWithOtherArgs.t.Errorf("ContextAccepterMock.AcceptContextWithOtherArgs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmAcceptContextWithOtherArgs.t.Errorf("ContextAccepterMock.AcceptContextWithOtherArgs got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptContextWithOtherArgs.t.Errorf("ContextAccepterMock.AcceptContextWithOtherArgs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptContextWithOtherArgs.t.Fatal("No results are set for the ContextAccepterMock.AcceptContextWithOtherArgs")
		}
		return (*mm_results).i2, (*mm_results).err
	}
	if mmAcceptContextWithOtherArgs.funcAcceptContextWithOtherArgs != nil {
		return mmAcceptContextWithOtherArgs.funcAcceptContextWithOtherArgs(ctx, i1)
	}
	mmAcceptContextWithOtherArgs.t.Fatalf("Unexpected call to ContextAccepterMock.AcceptContextWithOtherArgs. %v %v", ctx, i1)
	return
}

// AcceptContextWithOtherArgsAfterCounter returns a count of finished ContextAccepterMock.AcceptContextWithOtherArgs invocations
func (mmAcceptContextWithOtherArgs *ContextAccepterMock) AcceptContextWithOtherArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.afterAcceptContextWithOtherArgsCounter)
}

// AcceptContextWithOtherArgsBeforeCounter returns a count of ContextAccepterMock.AcceptContextWithOtherArgs invocations
func (mmAcceptContextWithOtherArgs *ContextAccepterMock) AcceptContextWithOtherArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.beforeAcceptContextWithOtherArgsCounter)
}

// Calls returns a list of arguments used in each call to ContextAccepterMock.AcceptContextWithOtherArgs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Calls() []*ContextAccepterMockAcceptContextWithOtherArgsParams {
	mmAcceptContextWithOtherArgs.mutex.RLock()

	argCopy := make([]*ContextAccepterMockAcceptContextWithOtherArgsParams, len(mmAcceptContextWithOtherArgs.callArgs))
	copy(argCopy, mmAcceptContextWithOtherArgs.callArgs)

	mmAcceptContextWithOtherArgs.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptContextWithOtherArgsDone returns true if the count of the AcceptContextWithOtherArgs invocations corresponds
// the number of defined expectations
func (m *ContextAccepterMock) MinimockAcceptContextWithOtherArgsDone() bool {
	if m.AcceptContextWithOtherArgsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptContextWithOtherArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptContextWithOtherArgsMock.invocationsDone()
}

// MinimockAcceptContextWithOtherArgsInspect logs each unmet expectation
func (m *ContextAccepterMock) MinimockAcceptContextWithOtherArgsInspect() {
	for _, e := range m.AcceptContextWithOtherArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptContextWithOtherArgsCounter := mm_atomic.LoadUint64(&m.afterAcceptContextWithOtherArgsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextWithOtherArgsMock.defaultExpectation != nil && afterAcceptContextWithOtherArgsCounter < 1 {
		if m.AcceptContextWithOtherArgsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs at\n%s", m.AcceptContextWithOtherArgsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs at\n%s with params: %#v", m.AcceptContextWithOtherArgsMock.defaultExpectation.expectationOrigins.origin, *m.AcceptContextWithOtherArgsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContextWithOtherArgs != nil && afterAcceptContextWithOtherArgsCounter < 1 {
		m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs at\n%s", m.funcAcceptContextWithOtherArgsOrigin)
	}

	if !m.AcceptContextWithOtherArgsMock.invocationsDone() && afterAcceptContextWithOtherArgsCounter > 0 {
		m.t.Errorf("Expected %d calls to ContextAccepterMock.AcceptContextWithOtherArgs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptContextWithOtherArgsMock.expectedInvocations), m.AcceptContextWithOtherArgsMock.expectedInvocationsOrigin, afterAcceptContextWithOtherArgsCounter)
	}
}

type mContextAccepterMockAcceptContextWithStructArgs struct {
	optional           bool
	mock               *ContextAccepterMock
	defaultExpectation *ContextAccepterMockAcceptContextWithStructArgsExpectation
	expectations       []*ContextAccepterMockAcceptContextWithStructArgsExpectation

	callArgs []*ContextAccepterMockAcceptContextWithStructArgsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ContextAccepterMockAcceptContextWithStructArgsExpectation specifies expectation struct of the contextAccepter.AcceptContextWithStructArgs
type ContextAccepterMockAcceptContextWithStructArgsExpectation struct {
	mock               *ContextAccepterMock
	params             *ContextAccepterMockAcceptContextWithStructArgsParams
	paramPtrs          *ContextAccepterMockAcceptContextWithStructArgsParamPtrs
	expectationOrigins ContextAccepterMockAcceptContextWithStructArgsExpectationOrigins
	results            *ContextAccepterMockAcceptContextWithStructArgsResults
	returnOrigin       string
	Counter            uint64
}

// ContextAccepterMockAcceptContextWithStructArgsParams contains parameters of the contextAccepter.AcceptContextWithStructArgs
type ContextAccepterMockAcceptContextWithStructArgsParams struct {
	ctx context.Context
	s1  structArg
}

// ContextAccepterMockAcceptContextWithStructArgsParamPtrs contains pointers to parameters of the contextAccepter.AcceptContextWithStructArgs
type ContextAccepterMockAcceptContextWithStructArgsParamPtrs struct {
	ctx *context.Context
	s1  *structArg
}

// ContextAccepterMockAcceptContextWithStructArgsResults contains results of the contextAccepter.AcceptContextWithStructArgs
type ContextAccepterMockAcceptContextWithStructArgsResults struct {
	i1  int
	err error
}

// ContextAccepterMockAcceptContextWithStructArgsOrigins contains origins of expectations of the contextAccepter.AcceptContextWithStructArgs
type ContextAccepterMockAcceptContextWithStructArgsExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Optional() *mContextAccepterMockAcceptContextWithStructArgs {
	mmAcceptContextWithStructArgs.optional = true
	return mmAcceptContextWithStructArgs
}

// Expect sets up expected params for contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Expect(ctx context.Context, s1 structArg) *mContextAccepterMockAcceptContextWithStructArgs {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation == nil {
		mmAcceptContextWithStructArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithStructArgsExpectation{}
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by ExpectParams functions")
	}

	mmAcceptContextWithStructArgs.defaultExpectation.params = &ContextAccepterMockAcceptContextWithStructArgsParams{ctx, s1}
	mmAcceptContextWithStructArgs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptContextWithStructArgs.expectations {
		if minimock.Equal(e.params, mmAcceptContextWithStructArgs.defaultExpectation.params) {
			mmAcceptContextWithStructArgs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptContextWithStructArgs.defaultExpectation.params)
		}
	}

	return mmAcceptContextWithStructArgs
}

// ExpectCtxParam1 sets up expected param ctx for contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) ExpectCtxParam1(ctx context.Context) *mContextAccepterMockAcceptContextWithStructArgs {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation == nil {
		mmAcceptContextWithStructArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithStructArgsExpectation{}
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.params != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Expect")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs == nil {
		mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextWithStructArgsParamPtrs{}
	}
	mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs.ctx = &ctx
	mmAcceptContextWithStructArgs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAcceptContextWithStructArgs
}

// ExpectS1Param2 sets up expected param s1 for contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) ExpectS1Param2(s1 structArg) *mContextAccepterMockAcceptContextWithStructArgs {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation == nil {
		mmAcceptContextWithStructArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithStructArgsExpectation{}
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.params != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Expect")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs == nil {
		mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextWithStructArgsParamPtrs{}
	}
	mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs.s1 = &s1
	mmAcceptContextWithStructArgs.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmAcceptContextWithStructArgs
}

// Inspect accepts an inspector function that has same arguments as the contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Inspect(f func(ctx context.Context, s1 structArg)) *mContextAccepterMockAcceptContextWithStructArgs {
	if mmAcceptContextWithStructArgs.mock.inspectFuncAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("Inspect function is already set for ContextAccepterMock.AcceptContextWithStructArgs")
	}

	mmAcceptContextWithStructArgs.mock.inspectFuncAcceptContextWithStructArgs = f

	return mmAcceptContextWithStructArgs
}

// Return sets up results that will be returned by contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Return(i1 int, err error) *ContextAccepterMock {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation == nil {
		mmAcceptContextWithStructArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithStructArgsExpectation{mock: mmAcceptContextWithStructArgs.mock}
	}
	mmAcceptContextWithStructArgs.defaultExpectation.results = &ContextAccepterMockAcceptContextWithStructArgsResults{i1, err}
	mmAcceptContextWithStructArgs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptContextWithStructArgs.mock
}

// Set uses given function f to mock the contextAccepter.AcceptContextWithStructArgs method
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Set(f func(ctx context.Context, s1 structArg) (i1 int, err error)) *ContextAccepterMock {
	if mmAcceptContextWithStructArgs.defaultExpectation != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("Default expectation is already set for the contextAccepter.AcceptContextWithStructArgs method")
	}

	if len(mmAcceptContextWithStructArgs.expectations) > 0 {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("Some expectations are already set for the contextAccepter.AcceptContextWithStructArgs method")
	}

	mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs = f
	mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgsOrigin = minimock.CallerInfo(1)
	return mmAcceptContextWithStructArgs.mock
}

// When sets expectation for the contextAccepter.AcceptContextWithStructArgs which will trigger the result defined by the following
// Then helper
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) When(ctx context.Context, s1 structArg) *ContextAccepterMockAcceptContextWithStructArgsExpectation {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	expectation := &ContextAccepterMockAcceptContextWithStructArgsExpectation{
		mock:               mmAcceptContextWithStructArgs.mock,
		params:             &ContextAccepterMockAcceptContextWithStructArgsParams{ctx, s1},
		expectationOrigins: ContextAccepterMockAcceptContextWithStructArgsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptContextWithStructArgs.expectations = append(mmAcceptContextWithStructArgs.expectations, expectation)
	return expectation
}

// Then sets up contextAccepter.AcceptContextWithStructArgs return parameters for the expectation previously defined by the When method
func (e *ContextAccepterMockAcceptContextWithStructArgsExpectation) Then(i1 int, err error) *ContextAccepterMock {
	e.results = &ContextAccepterMockAcceptContextWithStructArgsResults{i1, err}
	return e.mock
}

// Times sets number of times contextAccepter.AcceptContextWithStructArgs should be invoked
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Times(n uint64) *mContextAccepterMockAcceptContextWithStructArgs {
	if n == 0 {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("Times of ContextAccepterMock.AcceptContextWithStructArgs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptContextWithStructArgs.expectedInvocations, n)
	mmAcceptContextWithStructArgs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptContextWithStructArgs
}

func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) invocationsDone() bool {
	if len(mmAcceptContextWithStructArgs.expectations) == 0 && mmAcceptContextWithStructArgs.defaultExpectation == nil && mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptContextWithStructArgs.mock.afterAcceptContextWithStructArgsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptContextWithStructArgs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptContextWithStructArgs implements contextAccepter
func (mmAcceptContextWithStructArgs *ContextAccepterMock) AcceptContextWithStructArgs(ctx context.Context, s1 structArg) (i1 int, err error) {
	mm_atomic.AddUint64(&mmAcceptContextWithStructArgs.beforeAcceptContextWithStructArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptContextWithStructArgs.afterAcceptContextWithStructArgsCounter, 1)

	mmAcceptContextWithStructArgs.t.Helper()

	if mmAcceptContextWithStructArgs.inspectFuncAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.inspectFuncAcceptContextWithStructArgs(ctx, s1)
	}

	mm_params := ContextAccepterMockAcceptContextWithStructArgsParams{ctx, s1}

	// Record call args
	mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.mutex.Lock()
	mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.callArgs = append(mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.callArgs, &mm_params)
	mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.mutex.Unlock()

	for _, e := range mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.paramPtrs

		mm_got := ContextAccepterMockAcceptContextWithStructArgsParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptContextWithStructArgs.t.Errorf("ContextAccepterMock.AcceptContextWithStructArgs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmAcceptContextWithStructArgs.t.Errorf("ContextAccepterMock.AcceptContextWithStructArgs got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptContextWithStructArgs.t.Errorf("ContextAccepterMock.AcceptContextWithStructArgs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptContextWithStructArgs.t.Fatal("No results are set for the ContextAccepterMock.AcceptContextWithStructArgs")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAcceptContextWithStructArgs.funcAcceptContextWithStructArgs != nil {
		return mmAcceptContextWithStructArgs.funcAcceptContextWithStructArgs(ctx, s1)
	}
	mmAcceptContextWithStructArgs.t.Fatalf("Unexpected call to ContextAccepterMock.AcceptContextWithStructArgs. %v %v", ctx, s1)
	return
}

// AcceptContextWithStructArgsAfterCounter returns a count of finished ContextAccepterMock.AcceptContextWithStructArgs invocations
func (mmAcceptContextWithStructArgs *ContextAccepterMock) AcceptContextWithStructArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithStructArgs.afterAcceptContextWithStructArgsCounter)
}

// AcceptContextWithStructArgsBeforeCounter returns a count of ContextAccepterMock.AcceptContextWithStructArgs invocations
func (mmAcceptContextWithStructArgs *ContextAccepterMock) AcceptContextWithStructArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithStructArgs.beforeAcceptContextWithStructArgsCounter)
}

// Calls returns a list of arguments used in each call to ContextAccepterMock.AcceptContextWithStructArgs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Calls() []*ContextAccepterMockAcceptContextWithStructArgsParams {
	mmAcceptContextWithStructArgs.mutex.RLock()

	argCopy := make([]*ContextAccepterMockAcceptContextWithStructArgsParams, len(mmAcceptContextWithStructArgs.callArgs))
	copy(argCopy, mmAcceptContextWithStructArgs.callArgs)

	mmAcceptContextWithStructArgs.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptContextWithStructArgsDone returns true if the count of the AcceptContextWithStructArgs invocations corresponds
// the number of defined expectations
func (m *ContextAccepterMock) MinimockAcceptContextWithStructArgsDone() bool {
	if m.AcceptContextWithStructArgsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptContextWithStructArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptContextWithStructArgsMock.invocationsDone()
}

// MinimockAcceptContextWithStructArgsInspect logs each unmet expectation
func (m *ContextAccepterMock) MinimockAcceptContextWithStructArgsInspect() {
	for _, e := range m.AcceptContextWithStructArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithStructArgs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptContextWithStructArgsCounter := mm_atomic.LoadUint64(&m.afterAcceptContextWithStructArgsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextWithStructArgsMock.defaultExpectation != nil && afterAcceptContextWithStructArgsCounter < 1 {
		if m.AcceptContextWithStructArgsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithStructArgs at\n%s", m.AcceptContextWithStructArgsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithStructArgs at\n%s with params: %#v", m.AcceptContextWithStructArgsMock.defaultExpectation.expectationOrigins.origin, *m.AcceptContextWithStructArgsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContextWithStructArgs != nil && afterAcceptContextWithStructArgsCounter < 1 {
		m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithStructArgs at\n%s", m.funcAcceptContextWithStructArgsOrigin)
	}

	if !m.AcceptContextWithStructArgsMock.invocationsDone() && afterAcceptContextWithStructArgsCounter > 0 {
		m.t.Errorf("Expected %d calls to ContextAccepterMock.AcceptContextWithStructArgs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptContextWithStructArgsMock.expectedInvocations), m.AcceptContextWithStructArgsMock.expectedInvocationsOrigin, afterAcceptContextWithStructArgsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContextAccepterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcceptContextInspect()

			m.MinimockAcceptContextWithOtherArgsInspect()

			m.MinimockAcceptContextWithStructArgsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContextAccepterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContextAccepterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptContextDone() &&
		m.MinimockAcceptContextWithOtherArgsDone() &&
		m.MinimockAcceptContextWithStructArgsDone()
}
