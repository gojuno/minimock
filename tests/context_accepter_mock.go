// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package tests

//go:generate minimock -i github.com/gojuno/minimock/v3/tests.contextAccepter -o context_accepter_mock.go -n ContextAccepterMock -p tests

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ContextAccepterMock implements contextAccepter
type ContextAccepterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcceptContext          func(ctx context.Context)
	inspectFuncAcceptContext   func(ctx context.Context)
	afterAcceptContextCounter  uint64
	beforeAcceptContextCounter uint64
	AcceptContextMock          mContextAccepterMockAcceptContext

	funcAcceptContextWithOtherArgs          func(ctx context.Context, i1 int) (i2 int, err error)
	inspectFuncAcceptContextWithOtherArgs   func(ctx context.Context, i1 int)
	afterAcceptContextWithOtherArgsCounter  uint64
	beforeAcceptContextWithOtherArgsCounter uint64
	AcceptContextWithOtherArgsMock          mContextAccepterMockAcceptContextWithOtherArgs

	funcAcceptContextWithStructArgs          func(ctx context.Context, s1 structArg) (i1 int, err error)
	inspectFuncAcceptContextWithStructArgs   func(ctx context.Context, s1 structArg)
	afterAcceptContextWithStructArgsCounter  uint64
	beforeAcceptContextWithStructArgsCounter uint64
	AcceptContextWithStructArgsMock          mContextAccepterMockAcceptContextWithStructArgs
}

// NewContextAccepterMock returns a mock for contextAccepter
func NewContextAccepterMock(t minimock.Tester) *ContextAccepterMock {
	m := &ContextAccepterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptContextMock = mContextAccepterMockAcceptContext{mock: m}
	m.AcceptContextMock.callArgs = []*ContextAccepterMockAcceptContextParams{}

	m.AcceptContextWithOtherArgsMock = mContextAccepterMockAcceptContextWithOtherArgs{mock: m}
	m.AcceptContextWithOtherArgsMock.callArgs = []*ContextAccepterMockAcceptContextWithOtherArgsParams{}

	m.AcceptContextWithStructArgsMock = mContextAccepterMockAcceptContextWithStructArgs{mock: m}
	m.AcceptContextWithStructArgsMock.callArgs = []*ContextAccepterMockAcceptContextWithStructArgsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mContextAccepterMockAcceptContext struct {
	mock               *ContextAccepterMock
	defaultExpectation *ContextAccepterMockAcceptContextExpectation
	expectations       []*ContextAccepterMockAcceptContextExpectation

	callArgs []*ContextAccepterMockAcceptContextParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ContextAccepterMockAcceptContextExpectation specifies expectation struct of the contextAccepter.AcceptContext
type ContextAccepterMockAcceptContextExpectation struct {
	mock      *ContextAccepterMock
	params    *ContextAccepterMockAcceptContextParams
	paramPtrs *ContextAccepterMockAcceptContextParamPtrs

	Counter uint64
}

// ContextAccepterMockAcceptContextParams contains parameters of the contextAccepter.AcceptContext
type ContextAccepterMockAcceptContextParams struct {
	ctx context.Context
}

// ContextAccepterMockAcceptContextParamPtrs contains pointers to parameters of the contextAccepter.AcceptContext
type ContextAccepterMockAcceptContextParamPtrs struct {
	ctx *context.Context
}

// Expect sets up expected params for contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) Expect(ctx context.Context) *mContextAccepterMockAcceptContext {
	if mmAcceptContext.mock.funcAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Set")
	}

	if mmAcceptContext.defaultExpectation == nil {
		mmAcceptContext.defaultExpectation = &ContextAccepterMockAcceptContextExpectation{}
	}

	if mmAcceptContext.defaultExpectation.paramPtrs != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by ExpectParams functions")
	}

	mmAcceptContext.defaultExpectation.params = &ContextAccepterMockAcceptContextParams{ctx}
	for _, e := range mmAcceptContext.expectations {
		if minimock.Equal(e.params, mmAcceptContext.defaultExpectation.params) {
			mmAcceptContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptContext.defaultExpectation.params)
		}
	}

	return mmAcceptContext
}

// ExpectCtxParam1 sets up expected param ctx for contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) ExpectCtxParam1(ctx context.Context) *mContextAccepterMockAcceptContext {
	if mmAcceptContext.mock.funcAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Set")
	}

	if mmAcceptContext.defaultExpectation == nil {
		mmAcceptContext.defaultExpectation = &ContextAccepterMockAcceptContextExpectation{}
	}

	if mmAcceptContext.defaultExpectation.params != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Expect")
	}

	if mmAcceptContext.defaultExpectation.paramPtrs == nil {
		mmAcceptContext.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextParamPtrs{}
	}
	mmAcceptContext.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAcceptContext
}

// Inspect accepts an inspector function that has same arguments as the contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) Inspect(f func(ctx context.Context)) *mContextAccepterMockAcceptContext {
	if mmAcceptContext.mock.inspectFuncAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("Inspect function is already set for ContextAccepterMock.AcceptContext")
	}

	mmAcceptContext.mock.inspectFuncAcceptContext = f

	return mmAcceptContext
}

// Return sets up results that will be returned by contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) Return() *ContextAccepterMock {
	if mmAcceptContext.mock.funcAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Set")
	}

	if mmAcceptContext.defaultExpectation == nil {
		mmAcceptContext.defaultExpectation = &ContextAccepterMockAcceptContextExpectation{mock: mmAcceptContext.mock}
	}

	return mmAcceptContext.mock
}

// Set uses given function f to mock the contextAccepter.AcceptContext method
func (mmAcceptContext *mContextAccepterMockAcceptContext) Set(f func(ctx context.Context)) *ContextAccepterMock {
	if mmAcceptContext.defaultExpectation != nil {
		mmAcceptContext.mock.t.Fatalf("Default expectation is already set for the contextAccepter.AcceptContext method")
	}

	if len(mmAcceptContext.expectations) > 0 {
		mmAcceptContext.mock.t.Fatalf("Some expectations are already set for the contextAccepter.AcceptContext method")
	}

	mmAcceptContext.mock.funcAcceptContext = f
	return mmAcceptContext.mock
}

func (mmAcceptContext *mContextAccepterMockAcceptContext) Times(n uint64) *mContextAccepterMockAcceptContext {
	if n == 0 {
		mmAcceptContext.mock.t.Fatalf("Times of ContextAccepterMock.AcceptContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptContext.expectedInvocations, n)
	return mmAcceptContext
}

func (mmAcceptContext *mContextAccepterMockAcceptContext) invocationsDone() bool {
	if len(mmAcceptContext.expectations) == 0 && mmAcceptContext.defaultExpectation == nil && mmAcceptContext.mock.funcAcceptContext == nil {
		// does not need to check invocations if no expectations, defaultExpectation or funcAcceptContext set
		return true
	}

	// if expectations were set we check total invocations
	// if default expectation was set then invocations count should be greater than zero
	// if func was set then invocations count should be greater than zero
	totalInvocations := mm_atomic.LoadUint64(&mmAcceptContext.mock.afterAcceptContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptContext implements contextAccepter
func (mmAcceptContext *ContextAccepterMock) AcceptContext(ctx context.Context) {
	mm_atomic.AddUint64(&mmAcceptContext.beforeAcceptContextCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptContext.afterAcceptContextCounter, 1)

	if mmAcceptContext.inspectFuncAcceptContext != nil {
		mmAcceptContext.inspectFuncAcceptContext(ctx)
	}

	mm_params := ContextAccepterMockAcceptContextParams{ctx}

	// Record call args
	mmAcceptContext.AcceptContextMock.mutex.Lock()
	mmAcceptContext.AcceptContextMock.callArgs = append(mmAcceptContext.AcceptContextMock.callArgs, &mm_params)
	mmAcceptContext.AcceptContextMock.mutex.Unlock()

	for _, e := range mmAcceptContext.AcceptContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAcceptContext.AcceptContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptContext.AcceptContextMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptContext.AcceptContextMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptContext.AcceptContextMock.defaultExpectation.paramPtrs

		mm_got := ContextAccepterMockAcceptContextParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptContext.t.Errorf("ContextAccepterMock.AcceptContext got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptContext.t.Errorf("ContextAccepterMock.AcceptContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAcceptContext.funcAcceptContext != nil {
		mmAcceptContext.funcAcceptContext(ctx)
		return
	}
	mmAcceptContext.t.Fatalf("Unexpected call to ContextAccepterMock.AcceptContext. %v", ctx)

}

// AcceptContextAfterCounter returns a count of finished ContextAccepterMock.AcceptContext invocations
func (mmAcceptContext *ContextAccepterMock) AcceptContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContext.afterAcceptContextCounter)
}

// AcceptContextBeforeCounter returns a count of ContextAccepterMock.AcceptContext invocations
func (mmAcceptContext *ContextAccepterMock) AcceptContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContext.beforeAcceptContextCounter)
}

// Calls returns a list of arguments used in each call to ContextAccepterMock.AcceptContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptContext *mContextAccepterMockAcceptContext) Calls() []*ContextAccepterMockAcceptContextParams {
	mmAcceptContext.mutex.RLock()

	argCopy := make([]*ContextAccepterMockAcceptContextParams, len(mmAcceptContext.callArgs))
	copy(argCopy, mmAcceptContext.callArgs)

	mmAcceptContext.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptContextDone returns true if the count of the AcceptContext invocations corresponds
// the number of defined expectations
func (m *ContextAccepterMock) MinimockAcceptContextDone() bool {
	for _, e := range m.AcceptContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptContextMock.invocationsDone()
}

// MinimockAcceptContextInspect logs each unmet expectation
func (m *ContextAccepterMock) MinimockAcceptContextInspect() {
	for _, e := range m.AcceptContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContext with params: %#v", *e.params)
		}
	}

	afterAcceptContextCounter := mm_atomic.LoadUint64(&m.afterAcceptContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextMock.defaultExpectation != nil && afterAcceptContextCounter < 1 {
		if m.AcceptContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContextAccepterMock.AcceptContext")
		} else {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContext with params: %#v", *m.AcceptContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContext != nil && afterAcceptContextCounter < 1 {
		m.t.Error("Expected call to ContextAccepterMock.AcceptContext")
	}

	if !m.AcceptContextMock.invocationsDone() && afterAcceptContextCounter > 0 {
		m.t.Errorf("Expected %d calls to ContextAccepterMock.AcceptContext but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptContextMock.expectedInvocations), afterAcceptContextCounter)
	}
}

type mContextAccepterMockAcceptContextWithOtherArgs struct {
	mock               *ContextAccepterMock
	defaultExpectation *ContextAccepterMockAcceptContextWithOtherArgsExpectation
	expectations       []*ContextAccepterMockAcceptContextWithOtherArgsExpectation

	callArgs []*ContextAccepterMockAcceptContextWithOtherArgsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ContextAccepterMockAcceptContextWithOtherArgsExpectation specifies expectation struct of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsExpectation struct {
	mock      *ContextAccepterMock
	params    *ContextAccepterMockAcceptContextWithOtherArgsParams
	paramPtrs *ContextAccepterMockAcceptContextWithOtherArgsParamPtrs
	results   *ContextAccepterMockAcceptContextWithOtherArgsResults
	Counter   uint64
}

// ContextAccepterMockAcceptContextWithOtherArgsParams contains parameters of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsParams struct {
	ctx context.Context
	i1  int
}

// ContextAccepterMockAcceptContextWithOtherArgsParamPtrs contains pointers to parameters of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsParamPtrs struct {
	ctx *context.Context
	i1  *int
}

// ContextAccepterMockAcceptContextWithOtherArgsResults contains results of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsResults struct {
	i2  int
	err error
}

// Expect sets up expected params for contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Expect(ctx context.Context, i1 int) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{}
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by ExpectParams functions")
	}

	mmAcceptContextWithOtherArgs.defaultExpectation.params = &ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1}
	for _, e := range mmAcceptContextWithOtherArgs.expectations {
		if minimock.Equal(e.params, mmAcceptContextWithOtherArgs.defaultExpectation.params) {
			mmAcceptContextWithOtherArgs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptContextWithOtherArgs.defaultExpectation.params)
		}
	}

	return mmAcceptContextWithOtherArgs
}

// ExpectCtxParam1 sets up expected param ctx for contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) ExpectCtxParam1(ctx context.Context) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{}
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.params != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Expect")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextWithOtherArgsParamPtrs{}
	}
	mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAcceptContextWithOtherArgs
}

// ExpectI1Param2 sets up expected param i1 for contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) ExpectI1Param2(i1 int) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{}
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.params != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Expect")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextWithOtherArgsParamPtrs{}
	}
	mmAcceptContextWithOtherArgs.defaultExpectation.paramPtrs.i1 = &i1

	return mmAcceptContextWithOtherArgs
}

// Inspect accepts an inspector function that has same arguments as the contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Inspect(f func(ctx context.Context, i1 int)) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.inspectFuncAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Inspect function is already set for ContextAccepterMock.AcceptContextWithOtherArgs")
	}

	mmAcceptContextWithOtherArgs.mock.inspectFuncAcceptContextWithOtherArgs = f

	return mmAcceptContextWithOtherArgs
}

// Return sets up results that will be returned by contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Return(i2 int, err error) *ContextAccepterMock {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{mock: mmAcceptContextWithOtherArgs.mock}
	}
	mmAcceptContextWithOtherArgs.defaultExpectation.results = &ContextAccepterMockAcceptContextWithOtherArgsResults{i2, err}
	return mmAcceptContextWithOtherArgs.mock
}

// Set uses given function f to mock the contextAccepter.AcceptContextWithOtherArgs method
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Set(f func(ctx context.Context, i1 int) (i2 int, err error)) *ContextAccepterMock {
	if mmAcceptContextWithOtherArgs.defaultExpectation != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Default expectation is already set for the contextAccepter.AcceptContextWithOtherArgs method")
	}

	if len(mmAcceptContextWithOtherArgs.expectations) > 0 {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Some expectations are already set for the contextAccepter.AcceptContextWithOtherArgs method")
	}

	mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs = f
	return mmAcceptContextWithOtherArgs.mock
}

// When sets expectation for the contextAccepter.AcceptContextWithOtherArgs which will trigger the result defined by the following
// Then helper
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) When(ctx context.Context, i1 int) *ContextAccepterMockAcceptContextWithOtherArgsExpectation {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	expectation := &ContextAccepterMockAcceptContextWithOtherArgsExpectation{
		mock:   mmAcceptContextWithOtherArgs.mock,
		params: &ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1},
	}
	mmAcceptContextWithOtherArgs.expectations = append(mmAcceptContextWithOtherArgs.expectations, expectation)
	return expectation
}

// Then sets up contextAccepter.AcceptContextWithOtherArgs return parameters for the expectation previously defined by the When method
func (e *ContextAccepterMockAcceptContextWithOtherArgsExpectation) Then(i2 int, err error) *ContextAccepterMock {
	e.results = &ContextAccepterMockAcceptContextWithOtherArgsResults{i2, err}
	return e.mock
}

func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Times(n uint64) *mContextAccepterMockAcceptContextWithOtherArgs {
	if n == 0 {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Times of ContextAccepterMock.AcceptContextWithOtherArgs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptContextWithOtherArgs.expectedInvocations, n)
	return mmAcceptContextWithOtherArgs
}

func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) invocationsDone() bool {
	if len(mmAcceptContextWithOtherArgs.expectations) == 0 && mmAcceptContextWithOtherArgs.defaultExpectation == nil && mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs == nil {
		// does not need to check invocations if no expectations, defaultExpectation or funcAcceptContextWithOtherArgs set
		return true
	}

	// if expectations were set we check total invocations
	// if default expectation was set then invocations count should be greater than zero
	// if func was set then invocations count should be greater than zero
	totalInvocations := mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.mock.afterAcceptContextWithOtherArgsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptContextWithOtherArgs implements contextAccepter
func (mmAcceptContextWithOtherArgs *ContextAccepterMock) AcceptContextWithOtherArgs(ctx context.Context, i1 int) (i2 int, err error) {
	mm_atomic.AddUint64(&mmAcceptContextWithOtherArgs.beforeAcceptContextWithOtherArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptContextWithOtherArgs.afterAcceptContextWithOtherArgsCounter, 1)

	if mmAcceptContextWithOtherArgs.inspectFuncAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.inspectFuncAcceptContextWithOtherArgs(ctx, i1)
	}

	mm_params := ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1}

	// Record call args
	mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.mutex.Lock()
	mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.callArgs = append(mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.callArgs, &mm_params)
	mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.mutex.Unlock()

	for _, e := range mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i2, e.results.err
		}
	}

	if mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.paramPtrs

		mm_got := ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptContextWithOtherArgs.t.Errorf("ContextAccepterMock.AcceptContextWithOtherArgs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmAcceptContextWithOtherArgs.t.Errorf("ContextAccepterMock.AcceptContextWithOtherArgs got unexpected parameter i1, want: %#v, got: %#v%s\n", *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptContextWithOtherArgs.t.Errorf("ContextAccepterMock.AcceptContextWithOtherArgs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptContextWithOtherArgs.t.Fatal("No results are set for the ContextAccepterMock.AcceptContextWithOtherArgs")
		}
		return (*mm_results).i2, (*mm_results).err
	}
	if mmAcceptContextWithOtherArgs.funcAcceptContextWithOtherArgs != nil {
		return mmAcceptContextWithOtherArgs.funcAcceptContextWithOtherArgs(ctx, i1)
	}
	mmAcceptContextWithOtherArgs.t.Fatalf("Unexpected call to ContextAccepterMock.AcceptContextWithOtherArgs. %v %v", ctx, i1)
	return
}

// AcceptContextWithOtherArgsAfterCounter returns a count of finished ContextAccepterMock.AcceptContextWithOtherArgs invocations
func (mmAcceptContextWithOtherArgs *ContextAccepterMock) AcceptContextWithOtherArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.afterAcceptContextWithOtherArgsCounter)
}

// AcceptContextWithOtherArgsBeforeCounter returns a count of ContextAccepterMock.AcceptContextWithOtherArgs invocations
func (mmAcceptContextWithOtherArgs *ContextAccepterMock) AcceptContextWithOtherArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.beforeAcceptContextWithOtherArgsCounter)
}

// Calls returns a list of arguments used in each call to ContextAccepterMock.AcceptContextWithOtherArgs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Calls() []*ContextAccepterMockAcceptContextWithOtherArgsParams {
	mmAcceptContextWithOtherArgs.mutex.RLock()

	argCopy := make([]*ContextAccepterMockAcceptContextWithOtherArgsParams, len(mmAcceptContextWithOtherArgs.callArgs))
	copy(argCopy, mmAcceptContextWithOtherArgs.callArgs)

	mmAcceptContextWithOtherArgs.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptContextWithOtherArgsDone returns true if the count of the AcceptContextWithOtherArgs invocations corresponds
// the number of defined expectations
func (m *ContextAccepterMock) MinimockAcceptContextWithOtherArgsDone() bool {
	for _, e := range m.AcceptContextWithOtherArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptContextWithOtherArgsMock.invocationsDone()
}

// MinimockAcceptContextWithOtherArgsInspect logs each unmet expectation
func (m *ContextAccepterMock) MinimockAcceptContextWithOtherArgsInspect() {
	for _, e := range m.AcceptContextWithOtherArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs with params: %#v", *e.params)
		}
	}

	afterAcceptContextWithOtherArgsCounter := mm_atomic.LoadUint64(&m.afterAcceptContextWithOtherArgsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextWithOtherArgsMock.defaultExpectation != nil && afterAcceptContextWithOtherArgsCounter < 1 {
		if m.AcceptContextWithOtherArgsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs")
		} else {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs with params: %#v", *m.AcceptContextWithOtherArgsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContextWithOtherArgs != nil && afterAcceptContextWithOtherArgsCounter < 1 {
		m.t.Error("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs")
	}

	if !m.AcceptContextWithOtherArgsMock.invocationsDone() && afterAcceptContextWithOtherArgsCounter > 0 {
		m.t.Errorf("Expected %d calls to ContextAccepterMock.AcceptContextWithOtherArgs but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptContextWithOtherArgsMock.expectedInvocations), afterAcceptContextWithOtherArgsCounter)
	}
}

type mContextAccepterMockAcceptContextWithStructArgs struct {
	mock               *ContextAccepterMock
	defaultExpectation *ContextAccepterMockAcceptContextWithStructArgsExpectation
	expectations       []*ContextAccepterMockAcceptContextWithStructArgsExpectation

	callArgs []*ContextAccepterMockAcceptContextWithStructArgsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ContextAccepterMockAcceptContextWithStructArgsExpectation specifies expectation struct of the contextAccepter.AcceptContextWithStructArgs
type ContextAccepterMockAcceptContextWithStructArgsExpectation struct {
	mock      *ContextAccepterMock
	params    *ContextAccepterMockAcceptContextWithStructArgsParams
	paramPtrs *ContextAccepterMockAcceptContextWithStructArgsParamPtrs
	results   *ContextAccepterMockAcceptContextWithStructArgsResults
	Counter   uint64
}

// ContextAccepterMockAcceptContextWithStructArgsParams contains parameters of the contextAccepter.AcceptContextWithStructArgs
type ContextAccepterMockAcceptContextWithStructArgsParams struct {
	ctx context.Context
	s1  structArg
}

// ContextAccepterMockAcceptContextWithStructArgsParamPtrs contains pointers to parameters of the contextAccepter.AcceptContextWithStructArgs
type ContextAccepterMockAcceptContextWithStructArgsParamPtrs struct {
	ctx *context.Context
	s1  *structArg
}

// ContextAccepterMockAcceptContextWithStructArgsResults contains results of the contextAccepter.AcceptContextWithStructArgs
type ContextAccepterMockAcceptContextWithStructArgsResults struct {
	i1  int
	err error
}

// Expect sets up expected params for contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Expect(ctx context.Context, s1 structArg) *mContextAccepterMockAcceptContextWithStructArgs {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation == nil {
		mmAcceptContextWithStructArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithStructArgsExpectation{}
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by ExpectParams functions")
	}

	mmAcceptContextWithStructArgs.defaultExpectation.params = &ContextAccepterMockAcceptContextWithStructArgsParams{ctx, s1}
	for _, e := range mmAcceptContextWithStructArgs.expectations {
		if minimock.Equal(e.params, mmAcceptContextWithStructArgs.defaultExpectation.params) {
			mmAcceptContextWithStructArgs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptContextWithStructArgs.defaultExpectation.params)
		}
	}

	return mmAcceptContextWithStructArgs
}

// ExpectCtxParam1 sets up expected param ctx for contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) ExpectCtxParam1(ctx context.Context) *mContextAccepterMockAcceptContextWithStructArgs {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation == nil {
		mmAcceptContextWithStructArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithStructArgsExpectation{}
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.params != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Expect")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs == nil {
		mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextWithStructArgsParamPtrs{}
	}
	mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAcceptContextWithStructArgs
}

// ExpectS1Param2 sets up expected param s1 for contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) ExpectS1Param2(s1 structArg) *mContextAccepterMockAcceptContextWithStructArgs {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation == nil {
		mmAcceptContextWithStructArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithStructArgsExpectation{}
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.params != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Expect")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs == nil {
		mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs = &ContextAccepterMockAcceptContextWithStructArgsParamPtrs{}
	}
	mmAcceptContextWithStructArgs.defaultExpectation.paramPtrs.s1 = &s1

	return mmAcceptContextWithStructArgs
}

// Inspect accepts an inspector function that has same arguments as the contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Inspect(f func(ctx context.Context, s1 structArg)) *mContextAccepterMockAcceptContextWithStructArgs {
	if mmAcceptContextWithStructArgs.mock.inspectFuncAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("Inspect function is already set for ContextAccepterMock.AcceptContextWithStructArgs")
	}

	mmAcceptContextWithStructArgs.mock.inspectFuncAcceptContextWithStructArgs = f

	return mmAcceptContextWithStructArgs
}

// Return sets up results that will be returned by contextAccepter.AcceptContextWithStructArgs
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Return(i1 int, err error) *ContextAccepterMock {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	if mmAcceptContextWithStructArgs.defaultExpectation == nil {
		mmAcceptContextWithStructArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithStructArgsExpectation{mock: mmAcceptContextWithStructArgs.mock}
	}
	mmAcceptContextWithStructArgs.defaultExpectation.results = &ContextAccepterMockAcceptContextWithStructArgsResults{i1, err}
	return mmAcceptContextWithStructArgs.mock
}

// Set uses given function f to mock the contextAccepter.AcceptContextWithStructArgs method
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Set(f func(ctx context.Context, s1 structArg) (i1 int, err error)) *ContextAccepterMock {
	if mmAcceptContextWithStructArgs.defaultExpectation != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("Default expectation is already set for the contextAccepter.AcceptContextWithStructArgs method")
	}

	if len(mmAcceptContextWithStructArgs.expectations) > 0 {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("Some expectations are already set for the contextAccepter.AcceptContextWithStructArgs method")
	}

	mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs = f
	return mmAcceptContextWithStructArgs.mock
}

// When sets expectation for the contextAccepter.AcceptContextWithStructArgs which will trigger the result defined by the following
// Then helper
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) When(ctx context.Context, s1 structArg) *ContextAccepterMockAcceptContextWithStructArgsExpectation {
	if mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithStructArgs mock is already set by Set")
	}

	expectation := &ContextAccepterMockAcceptContextWithStructArgsExpectation{
		mock:   mmAcceptContextWithStructArgs.mock,
		params: &ContextAccepterMockAcceptContextWithStructArgsParams{ctx, s1},
	}
	mmAcceptContextWithStructArgs.expectations = append(mmAcceptContextWithStructArgs.expectations, expectation)
	return expectation
}

// Then sets up contextAccepter.AcceptContextWithStructArgs return parameters for the expectation previously defined by the When method
func (e *ContextAccepterMockAcceptContextWithStructArgsExpectation) Then(i1 int, err error) *ContextAccepterMock {
	e.results = &ContextAccepterMockAcceptContextWithStructArgsResults{i1, err}
	return e.mock
}

func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Times(n uint64) *mContextAccepterMockAcceptContextWithStructArgs {
	if n == 0 {
		mmAcceptContextWithStructArgs.mock.t.Fatalf("Times of ContextAccepterMock.AcceptContextWithStructArgs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptContextWithStructArgs.expectedInvocations, n)
	return mmAcceptContextWithStructArgs
}

func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) invocationsDone() bool {
	if len(mmAcceptContextWithStructArgs.expectations) == 0 && mmAcceptContextWithStructArgs.defaultExpectation == nil && mmAcceptContextWithStructArgs.mock.funcAcceptContextWithStructArgs == nil {
		// does not need to check invocations if no expectations, defaultExpectation or funcAcceptContextWithStructArgs set
		return true
	}

	// if expectations were set we check total invocations
	// if default expectation was set then invocations count should be greater than zero
	// if func was set then invocations count should be greater than zero
	totalInvocations := mm_atomic.LoadUint64(&mmAcceptContextWithStructArgs.mock.afterAcceptContextWithStructArgsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptContextWithStructArgs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptContextWithStructArgs implements contextAccepter
func (mmAcceptContextWithStructArgs *ContextAccepterMock) AcceptContextWithStructArgs(ctx context.Context, s1 structArg) (i1 int, err error) {
	mm_atomic.AddUint64(&mmAcceptContextWithStructArgs.beforeAcceptContextWithStructArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptContextWithStructArgs.afterAcceptContextWithStructArgsCounter, 1)

	if mmAcceptContextWithStructArgs.inspectFuncAcceptContextWithStructArgs != nil {
		mmAcceptContextWithStructArgs.inspectFuncAcceptContextWithStructArgs(ctx, s1)
	}

	mm_params := ContextAccepterMockAcceptContextWithStructArgsParams{ctx, s1}

	// Record call args
	mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.mutex.Lock()
	mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.callArgs = append(mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.callArgs, &mm_params)
	mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.mutex.Unlock()

	for _, e := range mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.paramPtrs

		mm_got := ContextAccepterMockAcceptContextWithStructArgsParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptContextWithStructArgs.t.Errorf("ContextAccepterMock.AcceptContextWithStructArgs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmAcceptContextWithStructArgs.t.Errorf("ContextAccepterMock.AcceptContextWithStructArgs got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptContextWithStructArgs.t.Errorf("ContextAccepterMock.AcceptContextWithStructArgs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptContextWithStructArgs.AcceptContextWithStructArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptContextWithStructArgs.t.Fatal("No results are set for the ContextAccepterMock.AcceptContextWithStructArgs")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAcceptContextWithStructArgs.funcAcceptContextWithStructArgs != nil {
		return mmAcceptContextWithStructArgs.funcAcceptContextWithStructArgs(ctx, s1)
	}
	mmAcceptContextWithStructArgs.t.Fatalf("Unexpected call to ContextAccepterMock.AcceptContextWithStructArgs. %v %v", ctx, s1)
	return
}

// AcceptContextWithStructArgsAfterCounter returns a count of finished ContextAccepterMock.AcceptContextWithStructArgs invocations
func (mmAcceptContextWithStructArgs *ContextAccepterMock) AcceptContextWithStructArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithStructArgs.afterAcceptContextWithStructArgsCounter)
}

// AcceptContextWithStructArgsBeforeCounter returns a count of ContextAccepterMock.AcceptContextWithStructArgs invocations
func (mmAcceptContextWithStructArgs *ContextAccepterMock) AcceptContextWithStructArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithStructArgs.beforeAcceptContextWithStructArgsCounter)
}

// Calls returns a list of arguments used in each call to ContextAccepterMock.AcceptContextWithStructArgs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptContextWithStructArgs *mContextAccepterMockAcceptContextWithStructArgs) Calls() []*ContextAccepterMockAcceptContextWithStructArgsParams {
	mmAcceptContextWithStructArgs.mutex.RLock()

	argCopy := make([]*ContextAccepterMockAcceptContextWithStructArgsParams, len(mmAcceptContextWithStructArgs.callArgs))
	copy(argCopy, mmAcceptContextWithStructArgs.callArgs)

	mmAcceptContextWithStructArgs.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptContextWithStructArgsDone returns true if the count of the AcceptContextWithStructArgs invocations corresponds
// the number of defined expectations
func (m *ContextAccepterMock) MinimockAcceptContextWithStructArgsDone() bool {
	for _, e := range m.AcceptContextWithStructArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptContextWithStructArgsMock.invocationsDone()
}

// MinimockAcceptContextWithStructArgsInspect logs each unmet expectation
func (m *ContextAccepterMock) MinimockAcceptContextWithStructArgsInspect() {
	for _, e := range m.AcceptContextWithStructArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithStructArgs with params: %#v", *e.params)
		}
	}

	afterAcceptContextWithStructArgsCounter := mm_atomic.LoadUint64(&m.afterAcceptContextWithStructArgsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextWithStructArgsMock.defaultExpectation != nil && afterAcceptContextWithStructArgsCounter < 1 {
		if m.AcceptContextWithStructArgsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContextAccepterMock.AcceptContextWithStructArgs")
		} else {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithStructArgs with params: %#v", *m.AcceptContextWithStructArgsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContextWithStructArgs != nil && afterAcceptContextWithStructArgsCounter < 1 {
		m.t.Error("Expected call to ContextAccepterMock.AcceptContextWithStructArgs")
	}

	if !m.AcceptContextWithStructArgsMock.invocationsDone() && afterAcceptContextWithStructArgsCounter > 0 {
		m.t.Errorf("Expected %d calls to ContextAccepterMock.AcceptContextWithStructArgs but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptContextWithStructArgsMock.expectedInvocations), afterAcceptContextWithStructArgsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContextAccepterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcceptContextInspect()

			m.MinimockAcceptContextWithOtherArgsInspect()

			m.MinimockAcceptContextWithStructArgsInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContextAccepterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContextAccepterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptContextDone() &&
		m.MinimockAcceptContextWithOtherArgsDone() &&
		m.MinimockAcceptContextWithStructArgsDone()
}
